/****************************************************************************************
 * File: evaluation.rs
 * Author: Muhammad Baba Goni
 * Email: <muhammadgoni51@gmail.com>
 * Date:  02/03/2025
 *
 * Description:
 * ------------
 * This file implements the Interpreter for the scripting language.
 *
 * The Interpreter traverses the Abstract Syntax Tree (AST) and executes the program
 * by evaluating expressions, executing statements, and managing program state
 * (such as variables, functions, control flow, etc.).
 *
 * Responsibilities:
 * -----------------
 * - Walk through the AST nodes and perform computation.
 * - Manage memory context (variables, function scopes).
 * - Handle control flow constructs (if, while, for, etc.).
 * - Evaluate expressions, function calls, and built-in operations.
 * - Provide runtime error handling and reporting.
 *
 * Usage:
 * ------
 * After the AST is generated by the `parser`, the `interpreter` executes it to
 * produce side effects or outputs.
 *
 * License:
 * --------
 * MIT License or similar permissive licensing.
 ****************************************************************************************/

use std::cell::RefCell;
use std::collections::HashMap;
use std::{ env, fmt };
use std::net::{ TcpListener, TcpStream, UdpSocket };
use std::path::PathBuf;
use std::io::{ self, Write };
use std::sync::{ Arc, Mutex, RwLock };
use mysql::PooledConn;
use native_tls::{ TlsAcceptor, TlsStream };
use once_cell::sync::Lazy;
use crate::astnode::ASTNode;
use crate::easyplot::{
    mpl_figure,
    mpl_title,
    mpl_xlabel,
    mpl_ylabel,
    mpl_legend,
    mpl_grid,
    mpl_clear,
    mpl_subplots,
    mpl_area,
    mpl_boxplot,
    mpl_heatmap,
    mpl_contour,
    mpl_errorbar,
    mpl_quiver,
    mpl_savefig,
    mpl_show,
    mpl_showimage,
    mpl_plot,
    mpl_scatter,
    mpl_hist,
    mpl_bar,
    mpl_pie,
    mpl_step,
    mpl_violin,
    mpl_stem,
    mpl_bubble,
    mpl_stackedbar,
    mpl_polar,
    mpl_candlestick,
    mpl_radar,
    mpl_waterfall,
};

use crate::easyui::{
    add_to_container,
    close_form,
    createbutton,
    createcard,
    createcheckbox,
    createform,
    creategroupbox,
    createlabel,
    createpanel,
    createradiobox,
    createsidebar,
    createtextbox,
    exit,
    get_autosize,
    get_backcolor,
    get_border,
    get_cursor,
    get_fontname,
    get_fontsize,
    get_fontweight,
    get_forecolor,
    get_fullscreen,
    get_height,
    get_maximized,
    get_multiline,
    get_resizable,
    get_startposition,
    get_width,
    get_x,
    get_y,
    getchecked,
    getdock,
    getenabled,
    gettext,
    getvisibility,
    hide_form,
    restore_form,
    runapp,
    set_above,
    set_autosize,
    set_backcolor,
    set_below,
    set_border,
    set_cursor,
    set_fontname,
    set_fontsize,
    set_fontweight,
    set_forecolor,
    set_fullscreen,
    set_height,
    set_left,
    set_margin,
    set_maximized,
    set_multiline,
    set_padding,
    set_position,
    set_resizable,
    set_right,
    set_startposition,
    set_text_alignment,
    set_selected_text,
    getitem,
    save_file_dialog,
    open_file_dialog,
    get_dialog_result,
    folder_dialog,
    set_width,
    set_x,
    set_y,
    setchecked,
    setclickhandler,
    setdock,
    setenabled,
    settext,
    setvisibility,
    show_form,
    createcombobox,
    createlistbox,
    get_selected_index,
    get_selected_text,
    set_selected_index,
    createpages,
    createprogressbar,
    createpicturebox,
    createscrollbar,
    add_to_page,
    additem,
    addpage,
    setmax,
    setscrollmax,
    setscrollmin,
    setscrollvalue,
    setsmallchange,
    getscrollmax,
    getscrollmin,
    getscrollvalue,
    getsmallchange,
    setlargechange,
    getlargechange,
    setsizemode,
    setbarcolor,
    setbarstyle,
    setpageindex,
    settransition,
    setvalue,
    getbarcolor,
    setmin,
    getmin,
    getmax,
    showpage,
    removepage,
    hidepage,
    getbarstyle,
    getpageindex,
    getvalue,
    set_use_as_default_panel,
    createtimer,
    settimerenabled,
    gettimerenabled,
    get_dialog_filters,
    get_dialog_multiselect,
    get_dialog_startingpath,
    get_dialog_title,
    set_dialog_filters,
    set_dialog_multiselect,
    set_dialog_startingpath,
    set_dialog_title,
    settimerinterval,
    gettimerinterval,
    starttimer,
    stoptimer,
    show_message_box,
    get_message_box_response,
    createdatetimepicker,
    createmenu,
    createtable,
    add_menu_item,
    set_table_data,
    get_table_data,
    set_datetime,
    get_datetime,
    add_separator_item,
    add_submenu_item,
    createtimerpicker,
    create_colordialog,
    colordialog_show,
    colordialog_get_color,
    set_timerpicker_time,
    get_timerpicker_time,
    set_menu_item_icon,
    get_menu_item_icon,
    create_imagebutton,
    create_richtext,
    create_slider,
    create_statusbar,
    create_toolbar,
    create_treeview,
    createflowlayout,
    creategridlayout,
    createhorizontallayout,
    createseparator,
    createshape,
    createverticallayout,
    setspacing,
    getspacing,
    setgridlayoutcell,
    setgridlayoutcolumns,
    setgridlayoutrows,
    setseparatororientation,
    getgridlayoutcolumns,
    getgridlayoutrows,
    getseparatororientation,
    drawy_begin_fill,
    drawy_circle,
    drawy_end_fill,
    drawy_forward,
    drawy_left,
    drawy_pencolor,
    drawy_pendown,
    drawy_penup,
    drawy_right,
    drawy_speed,
    drawy_goto,
    treeview_add_node,
    toolbar_add_item,
    treeview_get_selected,
    treeview_set_selected,
    treeview_get_node,
    richtext_set_format,
    setimage,
    addgridlayoutcolumn,
    addgridlayoutrow,
    set_treeview_on_event,
    treeview_set_node_checkbox,
    treeview_set_node_icon,
    setgridlayoutshowlines,
    getgridlayoutshowlines,
};

use crate::listener::ListenerServer;
use crate::thread::{ self, ThreadHandle };
use crate::{ fetcher, system, listener };
use crate::token::TokenType;
use crate::lexer::Lexer;
use crate::parser::Parser;
use crate::{
    array,
    conversion,
    datetime,
    dictionary,
    filesystem,
    math,
    mysqli,
    socket,
    sqlite,
    string,
};
use std::thread::JoinHandle;
use lazy_static::lazy_static;

lazy_static! {
    pub static ref GLOBAL_INTERPRETER: Arc<Mutex<Interpreter>> = Arc::new(
        Mutex::new(Interpreter::new())
    );
}
thread_local! {
    pub static CURRENT_ENV: RefCell<Option<Arc<Mutex<Environment>>>> = RefCell::new(None);
}
// Debug implementation for TlsAcceptor
#[derive(Clone)]
pub struct DebugTlsAcceptor(pub Arc<Mutex<TlsAcceptor>>);

impl fmt::Debug for DebugTlsAcceptor {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "TlsAcceptor")
    }
}

// Represents runtime values in the language
#[derive(Clone, Debug)]
pub enum Value {
    Number(f64),
    String(String),
    Bool(bool),
    Null,
    Array(Vec<Arc<Mutex<Value>>>),
    Dictionary(HashMap<String, Arc<Mutex<Value>>>),
    Class {
        ast: Box<ASTNode>,
        env: Arc<Mutex<Environment>>,
    },
    Object {
        class: String,
        fields: HashMap<String, Arc<Mutex<Value>>>,
        class_ast: Box<ASTNode>,
        parent: Option<Arc<Mutex<Value>>>,
        module: Option<String>,
    },
    Function {
        name: String,
        params: Vec<(String, Option<Value>)>,
        body: Vec<ASTNode>,
        closure: Arc<Mutex<Environment>>,
        object: Option<Arc<Mutex<Value>>>,
    },
    BuiltinFunction(fn(Vec<Value>) -> Result<Value, String>),
    Error(String),
    ByteArray(Vec<u8>),
    Callback(String),
    Module {
        name: String,
        env: Arc<Mutex<Environment>>,
    },
    SQLiteConnection(Arc<Mutex<rusqlite::Connection>>),
    SQLiteResult(Vec<HashMap<String, Value>>),
    MySQLConnection(Arc<Mutex<PooledConn>>),
    MySQLResult(Vec<HashMap<String, Value>>),
    TcpStream(Arc<Mutex<TcpStream>>),
    TcpListener(Arc<Mutex<TcpListener>>),
    TCPConnection(Arc<Mutex<TcpStream>>),
    UdpSocket(Arc<Mutex<UdpSocket>>),
    TlsStream(Arc<Mutex<TlsStream<TcpStream>>>),
    TlsAcceptor(DebugTlsAcceptor),
    HTTPListener(Arc<Mutex<ListenerServer>>),
    HTTPClient(Arc<Mutex<reqwest::blocking::Client>>),
    HTTPResponse(String),
    ThreadHandle(ThreadHandle),
    FormObject(String),
    MessageBoxResult(String),
    Figure(Arc<Mutex<crate::easyplot::Figure>>),
    // Future(Box<dyn Future<Output = Value>>),
    //Future(Box<dyn std::future::Future<Output = Value> + Send>),
}

impl Value {
    fn to_bool(&self) -> bool {
        match self {
            Value::Bool(b) => *b,
            Value::Number(n) => *n != 0.0,
            Value::String(s) => !s.is_empty(),
            Value::Null => false,
            Value::Array(arr) => !arr.is_empty(),
            Value::Dictionary(dict) => !dict.is_empty(),
            _ => true,
        }
    }

    pub fn to_string(&self) -> String {
        match self {
            Value::Number(n) => n.to_string(),
            Value::String(s) => s.clone(),
            Value::Bool(b) => b.to_string(),
            Value::Null => "null".to_string(),
            Value::Array(arr) => {
                let elements: Vec<String> = arr
                    .iter()
                    .map(|v| v.lock().unwrap().to_string())
                    .collect();
                format!("[{}]", elements.join(", "))
            }
            Value::Dictionary(dict) => {
                let pairs: Vec<String> = dict
                    .iter()
                    .map(|(k, v)| format!("{}: {}", k, v.lock().unwrap().to_string()))
                    .collect();
                format!("{{{}}}", pairs.join(", "))
            }
            Value::Class { ast, .. } => {
                if let ASTNode::ClassDecl { name, .. } = &**ast {
                    format!("<class {}>", name)
                } else {
                    "<class unknown>".to_string()
                }
            }
            Value::Object { class, .. } => format!("<{} object>", class),
            Value::Function { name, .. } => format!("<function {}>", name),
            Value::Error(e) => format!("Error: {}", e),
            Value::ByteArray(bytes) => format!("ByteArray({})", bytes.len()),
            Value::Callback(name) => format!("<callback {}>", name),
            Value::BuiltinFunction(_) => "<builtin function>".to_string(),
            Value::Module { name, .. } => format!("<module {}>", name),
            Value::SQLiteConnection(_) => "<SQLite Connection>".to_string(),
            Value::SQLiteResult(_) => "<SQLite Result>".to_string(),
            Value::MySQLConnection(_) => "<MySQL Connection>".to_string(),
            Value::MySQLResult(_) => "<MySQL Result>".to_string(),
            Value::TcpStream(_) => "<TcpStream>".to_string(),
            Value::TcpListener(_) => "<TcpListener>".to_string(),
            Value::UdpSocket(_) => "<UdpSocket>".to_string(),
            Value::TlsStream(_) => "<TlsStream>".to_string(),
            Value::TlsAcceptor(_) => "<TlsAcceptor>".to_string(),
            Value::HTTPListener(_) => "<HTTPListener>".to_string(),
            Value::ThreadHandle(_) => todo!(),
            Value::FormObject(s) => s.clone(),
            Value::Figure(_) => todo!(),
            Value::MessageBoxResult(s) => s.clone(),
            Value::TCPConnection(mutex) => "<TCPConnection>".to_string(),
            Value::HTTPClient(mutex) => "<HTTPClient>".to_string(),
            Value::HTTPResponse(_) => "<HTTPResponse>".to_string(),
        }
    }
}

impl PartialEq for Value {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (Value::Number(a), Value::Number(b)) => a == b,
            (Value::String(a), Value::String(b)) => a == b,
            (Value::Bool(a), Value::Bool(b)) => a == b,
            (Value::Null, Value::Null) => true,
            _ => false,
        }
    }
}

// Represents control flow outcomes
#[derive(Debug)]
pub enum ControlFlow {
    Normal(Value),
    Return(Value),
    Break,
    Continue,
    Throw(Value),
    Yield(Value),
    //Await(Box<dyn Future<Output = Value>>),
}

// Manages variable scopes
#[derive(Debug)]
pub struct Environment {
    values: RwLock<HashMap<String, Arc<Mutex<Value>>>>,
    parent: Option<Arc<Mutex<Environment>>>,
    object: Option<Arc<Mutex<Value>>>,
}

impl Environment {
    pub fn new(parent: Option<Arc<Mutex<Environment>>>) -> Self {
        Environment {
            values: RwLock::new(HashMap::new()),
            parent,
            object: None,
        }
    }

    pub fn define(&self, name: String, value: Value) -> Result<(), String> {
        let mut values = self.values.write().unwrap();
        if values.contains_key(&name) {
            Err(format!("Name Error: Variable '{}' already defined", name))
        } else {
            values.insert(name, Arc::new(Mutex::new(value)));
            Ok(())
        }
    }

    pub fn reassign(&self, name: String, value: Value) -> Result<(), String> {
        let mut values = self.values.write().unwrap();
        if let Some(cell) = values.get(&name) {
            *cell.lock().unwrap() = value;
        } else {
            values.insert(name, Arc::new(Mutex::new(value)));
        }
        Ok(())
    }

    pub fn get(&self, name: &str) -> Result<Arc<Mutex<Value>>, String> {
        let values = self.values.read().unwrap();
        if let Some(value) = values.get(name) {
            Ok(value.clone())
        } else if let Some(obj) = &self.object {
            let obj_guard = obj.lock().unwrap();
            if let Value::Object { fields, .. } = &*obj_guard {
                if let Some(field) = fields.get(name) {
                    Ok(field.clone())
                } else {
                    self.parent
                        .as_ref()
                        .map_or(Err(format!("Name Error: Variable '{}' not found", name)), |p|
                            p.lock().unwrap().get(name)
                        )
                }
            } else {
                self.parent
                    .as_ref()
                    .map_or(Err(format!("Name Error: Variable '{}' not found", name)), |p|
                        p.lock().unwrap().get(name)
                    )
            }
        } else {
            self.parent
                .as_ref()
                .map_or(Err(format!("Name Error: Variable '{}' not found", name)), |p|
                    p.lock().unwrap().get(name)
                )
        }
    }

    pub fn assign(&self, name: &str, value: Value) -> Result<(), String> {
        if let Some(var) = self.values.read().unwrap().get(name) {
            *var.lock().unwrap() = value;
            Ok(())
        } else if let Some(obj) = &self.object {
            let obj_guard = obj.lock().unwrap();
            if let Value::Object { fields, .. } = &*obj_guard {
                if let Some(field) = fields.get(name) {
                    *field.lock().unwrap() = value;
                    Ok(())
                } else {
                    self.parent
                        .as_ref()
                        .map_or(Err(format!("Name Error: Variable '{}' not found", name)), |p|
                            p.lock().unwrap().assign(name, value)
                        )
                }
            } else {
                self.parent
                    .as_ref()
                    .map_or(Err(format!("Name Error: Variable '{}' not found", name)), |p|
                        p.lock().unwrap().assign(name, value)
                    )
            }
        } else {
            self.parent
                .as_ref()
                .map_or(Err(format!("Name Error: Variable '{}' not found", name)), |p|
                    p.lock().unwrap().assign(name, value)
                )
        }
    }
}

// Main interpreter struct
pub struct Interpreter {
    classes: Arc<Mutex<HashMap<String, ASTNode>>>,
    modules: Arc<Mutex<HashMap<String, Arc<Mutex<Environment>>>>>,
    string_methods: Arc<HashMap<String, Value>>,
    array_methods: Arc<HashMap<String, Value>>,
    dict_methods: Arc<HashMap<String, Value>>,
}

impl Interpreter {
    pub fn new() -> Self {
        let classes = Arc::new(Mutex::new(HashMap::new()));
        let modules = Arc::new(Mutex::new(HashMap::new()));
        let string_methods = Arc::new(HashMap::new());
        let array_methods = Arc::new(HashMap::new());
        let dict_methods = Arc::new(HashMap::new());

        let mut interpreter = Interpreter {
            classes,
            modules,
            string_methods,
            array_methods,
            dict_methods,
        };

        // Initialize method hashmaps
        let mut string_methods_map = HashMap::new();
        string_methods_map.insert(
            "count".to_string(),
            Value::BuiltinFunction(string::string_count)
        );
        string_methods_map.insert(
            "contains".to_string(),
            Value::BuiltinFunction(string::string_contains)
        );
        string_methods_map.insert(
            "replace".to_string(),
            Value::BuiltinFunction(string::string_replace)
        );
        string_methods_map.insert(
            "substring".to_string(),
            Value::BuiltinFunction(string::string_substring)
        );
        string_methods_map.insert(
            "uppercase".to_string(),
            Value::BuiltinFunction(string::string_uppercase)
        );
        string_methods_map.insert(
            "lowercase".to_string(),
            Value::BuiltinFunction(string::string_lowercase)
        );
        string_methods_map.insert(
            "capitalize".to_string(),
            Value::BuiltinFunction(string::string_capitalize)
        );
        string_methods_map.insert(
            "reverse".to_string(),
            Value::BuiltinFunction(string::string_reverse)
        );
        string_methods_map.insert("join".to_string(), Value::BuiltinFunction(string::string_join));
        string_methods_map.insert(
            "tolist".to_string(),
            Value::BuiltinFunction(string::string_tolist)
        );
        string_methods_map.insert(
            "compare".to_string(),
            Value::BuiltinFunction(string::string_compare)
        );
        string_methods_map.insert("trim".to_string(), Value::BuiltinFunction(string::string_trim));
        string_methods_map.insert(
            "startswith".to_string(),
            Value::BuiltinFunction(string::string_startswith)
        );
        string_methods_map.insert(
            "endswith".to_string(),
            Value::BuiltinFunction(string::string_endswith)
        );
        string_methods_map.insert(
            "remove".to_string(),
            Value::BuiltinFunction(string::string_remove)
        );
        string_methods_map.insert(
            "split".to_string(),
            Value::BuiltinFunction(string::string_split)
        );
        string_methods_map.insert(
            "frombytes".to_string(),
            Value::BuiltinFunction(string::string_frombytes)
        );
        string_methods_map.insert(
            "format".to_string(),
            Value::BuiltinFunction(string::string_format)
        );
        string_methods_map.insert(
            "encode".to_string(),
            Value::BuiltinFunction(string::string_encode)
        );
        string_methods_map.insert(
            "decode".to_string(),
            Value::BuiltinFunction(string::string_decode)
        );
        string_methods_map.insert("find".to_string(), Value::BuiltinFunction(string::string_find));
        interpreter.string_methods = Arc::new(string_methods_map);

        let mut array_methods_map = HashMap::new();
        array_methods_map.insert("length".to_string(), Value::BuiltinFunction(array::array_length));
        array_methods_map.insert("append".to_string(), Value::BuiltinFunction(array::array_append));
        array_methods_map.insert("copy".to_string(), Value::BuiltinFunction(array::array_copy));
        array_methods_map.insert("clear".to_string(), Value::BuiltinFunction(array::array_clear));
        array_methods_map.insert("remove".to_string(), Value::BuiltinFunction(array::array_remove));
        array_methods_map.insert(
            "reverse".to_string(),
            Value::BuiltinFunction(array::array_reverse)
        );
        array_methods_map.insert("insert".to_string(), Value::BuiltinFunction(array::array_insert));
        array_methods_map.insert("sort".to_string(), Value::BuiltinFunction(array::array_sort));
        array_methods_map.insert(
            "indexof".to_string(),
            Value::BuiltinFunction(array::array_indexof)
        );
        array_methods_map.insert("pop".to_string(), Value::BuiltinFunction(array::array_pop));
        array_methods_map.insert("shift".to_string(), Value::BuiltinFunction(array::array_shift));
        array_methods_map.insert(
            "unshift".to_string(),
            Value::BuiltinFunction(array::array_unshift)
        );
        array_methods_map.insert("slice".to_string(), Value::BuiltinFunction(array::array_slice));
        array_methods_map.insert("splice".to_string(), Value::BuiltinFunction(array::array_splice));
        array_methods_map.insert("concat".to_string(), Value::BuiltinFunction(array::array_concat));
        array_methods_map.insert(
            "includes".to_string(),
            Value::BuiltinFunction(array::array_includes)
        );
        interpreter.array_methods = Arc::new(array_methods_map);

        let mut dict_methods_map = HashMap::new();
        dict_methods_map.insert("add".to_string(), Value::BuiltinFunction(dictionary::add));
        dict_methods_map.insert("get".to_string(), Value::BuiltinFunction(dictionary::get));
        dict_methods_map.insert("remove".to_string(), Value::BuiltinFunction(dictionary::remove));
        dict_methods_map.insert(
            "containskey".to_string(),
            Value::BuiltinFunction(dictionary::containskey)
        );
        dict_methods_map.insert(
            "containsvalue".to_string(),
            Value::BuiltinFunction(dictionary::containsvalue)
        );
        dict_methods_map.insert("size".to_string(), Value::BuiltinFunction(dictionary::size));
        dict_methods_map.insert("keys".to_string(), Value::BuiltinFunction(dictionary::keys));
        dict_methods_map.insert("values".to_string(), Value::BuiltinFunction(dictionary::values));
        dict_methods_map.insert("isempty".to_string(), Value::BuiltinFunction(dictionary::isempty));
        dict_methods_map.insert("clear".to_string(), Value::BuiltinFunction(dictionary::clear));
        dict_methods_map.insert("update".to_string(), Value::BuiltinFunction(dictionary::update));
        dict_methods_map.insert("merge".to_string(), Value::BuiltinFunction(dictionary::merge));
        dict_methods_map.insert("copy".to_string(), Value::BuiltinFunction(dictionary::copy));
        dict_methods_map.insert("tojson".to_string(), Value::BuiltinFunction(dictionary::tojson));
        dict_methods_map.insert("tofile".to_string(), Value::BuiltinFunction(dictionary::tofile));
        interpreter.dict_methods = Arc::new(dict_methods_map);

        // Initialize built-in modules
        let global_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let mut env_guard = global_env.lock().unwrap();
            env_guard
                .define("input".to_string(), Value::BuiltinFunction(Self::builtin_input))
                .expect("Failed to define built-in function 'input'");
        }

        let math_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("abs", math::math_abs as fn(Vec<Value>) -> Result<Value, String>),
                ("pow", math::math_pow as fn(Vec<Value>) -> Result<Value, String>),
                ("sqrt", math::math_sqrt as fn(Vec<Value>) -> Result<Value, String>),
                ("sin", math::math_sin as fn(Vec<Value>) -> Result<Value, String>),
                ("cos", math::math_cos as fn(Vec<Value>) -> Result<Value, String>),
                ("tan", math::math_tan as fn(Vec<Value>) -> Result<Value, String>),
                ("round", math::math_round as fn(Vec<Value>) -> Result<Value, String>),
                ("random", math::math_random as fn(Vec<Value>) -> Result<Value, String>),
                ("max", math::math_max as fn(Vec<Value>) -> Result<Value, String>),
                ("min", math::math_min as fn(Vec<Value>) -> Result<Value, String>),
                ("sum", math::math_sum as fn(Vec<Value>) -> Result<Value, String>),
                ("ceiling", math::math_ceiling as fn(Vec<Value>) -> Result<Value, String>),
                ("floor", math::math_floor as fn(Vec<Value>) -> Result<Value, String>),
                ("log10", math::math_log10 as fn(Vec<Value>) -> Result<Value, String>),
                ("average", math::math_average as fn(Vec<Value>) -> Result<Value, String>),
                ("log", math::math_log as fn(Vec<Value>) -> Result<Value, String>),
                ("exp", math::math_exp as fn(Vec<Value>) -> Result<Value, String>),
                ("mean", math::math_mean as fn(Vec<Value>) -> Result<Value, String>),
                ("mode", math::math_mode as fn(Vec<Value>) -> Result<Value, String>),
                ("sign", math::math_sign as fn(Vec<Value>) -> Result<Value, String>),
                ("log2", math::math_log2 as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = math_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define math.{}", name));
            }
        }

        let string_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("count", string::string_count as fn(Vec<Value>) -> Result<Value, String>),
                ("contains", string::string_contains as fn(Vec<Value>) -> Result<Value, String>),
                ("replace", string::string_replace as fn(Vec<Value>) -> Result<Value, String>),
                ("substring", string::string_substring as fn(Vec<Value>) -> Result<Value, String>),
                ("uppercase", string::string_uppercase as fn(Vec<Value>) -> Result<Value, String>),
                ("lowercase", string::string_lowercase as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "capitalize",
                    string::string_capitalize as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("reverse", string::string_reverse as fn(Vec<Value>) -> Result<Value, String>),
                ("join", string::string_join as fn(Vec<Value>) -> Result<Value, String>),
                ("tolist", string::string_tolist as fn(Vec<Value>) -> Result<Value, String>),
                ("compare", string::string_compare as fn(Vec<Value>) -> Result<Value, String>),
                ("trim", string::string_trim as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "startswith",
                    string::string_startswith as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("endswith", string::string_endswith as fn(Vec<Value>) -> Result<Value, String>),
                ("remove", string::string_remove as fn(Vec<Value>) -> Result<Value, String>),
                ("split", string::string_split as fn(Vec<Value>) -> Result<Value, String>),
                ("find", string::string_find as fn(Vec<Value>) -> Result<Value, String>),
                ("frombytes", string::string_frombytes as fn(Vec<Value>) -> Result<Value, String>),
                ("format", string::string_format as fn(Vec<Value>) -> Result<Value, String>),
                ("encode", string::string_encode as fn(Vec<Value>) -> Result<Value, String>),
                ("decode", string::string_decode as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = string_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define string.{}", name));
            }
        }

        let array_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("length", array::array_length as fn(Vec<Value>) -> Result<Value, String>),
                ("append", array::array_append as fn(Vec<Value>) -> Result<Value, String>),
                ("copy", array::array_copy as fn(Vec<Value>) -> Result<Value, String>),
                ("clear", array::array_clear as fn(Vec<Value>) -> Result<Value, String>),
                ("remove", array::array_remove as fn(Vec<Value>) -> Result<Value, String>),
                ("reverse", array::array_reverse as fn(Vec<Value>) -> Result<Value, String>),
                ("insert", array::array_insert as fn(Vec<Value>) -> Result<Value, String>),
                ("sort", array::array_sort as fn(Vec<Value>) -> Result<Value, String>),
                ("indexof", array::array_indexof as fn(Vec<Value>) -> Result<Value, String>),
                ("pop", array::array_pop as fn(Vec<Value>) -> Result<Value, String>),
                ("shift", array::array_shift as fn(Vec<Value>) -> Result<Value, String>),
                ("unshift", array::array_unshift as fn(Vec<Value>) -> Result<Value, String>),
                ("slice", array::array_slice as fn(Vec<Value>) -> Result<Value, String>),
                ("splice", array::array_splice as fn(Vec<Value>) -> Result<Value, String>),
                ("concat", array::array_concat as fn(Vec<Value>) -> Result<Value, String>),
                ("includes", array::array_includes as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = array_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define array.{}", name));
            }
        }

        let dict_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("add", dictionary::add as fn(Vec<Value>) -> Result<Value, String>),
                ("get", dictionary::get as fn(Vec<Value>) -> Result<Value, String>),
                ("remove", dictionary::remove as fn(Vec<Value>) -> Result<Value, String>),
                ("containskey", dictionary::containskey as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "containsvalue",
                    dictionary::containsvalue as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("size", dictionary::size as fn(Vec<Value>) -> Result<Value, String>),
                ("keys", dictionary::keys as fn(Vec<Value>) -> Result<Value, String>),
                ("items", dictionary::items as fn(Vec<Value>) -> Result<Value, String>),
                ("values", dictionary::values as fn(Vec<Value>) -> Result<Value, String>),
                ("isempty", dictionary::isempty as fn(Vec<Value>) -> Result<Value, String>),
                ("clear", dictionary::clear as fn(Vec<Value>) -> Result<Value, String>),
                ("update", dictionary::update as fn(Vec<Value>) -> Result<Value, String>),
                ("merge", dictionary::merge as fn(Vec<Value>) -> Result<Value, String>),
                ("copy", dictionary::copy as fn(Vec<Value>) -> Result<Value, String>),
                ("tojson", dictionary::tojson as fn(Vec<Value>) -> Result<Value, String>),
                ("tofile", dictionary::tofile as fn(Vec<Value>) -> Result<Value, String>),
                ("pop", dictionary::pop as fn(Vec<Value>) -> Result<Value, String>),
                ("popitem", dictionary::popitem as fn(Vec<Value>) -> Result<Value, String>),
                ("setdefault", dictionary::setdefault as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = dict_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define dict.{}", name));
            }
        }

        let datetime_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("today", datetime::today as fn(Vec<Value>) -> Result<Value, String>),
                ("timenow", datetime::timenow as fn(Vec<Value>) -> Result<Value, String>),
                ("datediff", datetime::datediff as fn(Vec<Value>) -> Result<Value, String>),
                ("dateadd", datetime::dateadd as fn(Vec<Value>) -> Result<Value, String>),
                ("dateformat", datetime::dateformat as fn(Vec<Value>) -> Result<Value, String>),
                ("dateparse", datetime::dateparse as fn(Vec<Value>) -> Result<Value, String>),
                ("timediff", datetime::timediff as fn(Vec<Value>) -> Result<Value, String>),
                ("timeadd", datetime::timeadd as fn(Vec<Value>) -> Result<Value, String>),
                ("timeformat", datetime::timeformat as fn(Vec<Value>) -> Result<Value, String>),
                ("timeparse", datetime::timeparse as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = datetime_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define datetime.{}", name));
            }
        }

        let conversion_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("toint", conversion::toint as fn(Vec<Value>) -> Result<Value, String>),
                ("todouble", conversion::todouble as fn(Vec<Value>) -> Result<Value, String>),
                ("tostring", conversion::tostring as fn(Vec<Value>) -> Result<Value, String>),
                ("isint", conversion::isint as fn(Vec<Value>) -> Result<Value, String>),
                ("isalnum", conversion::isalnum as fn(Vec<Value>) -> Result<Value, String>),
                ("isdigit", conversion::isdigit as fn(Vec<Value>) -> Result<Value, String>),
                ("isdouble", conversion::isdouble as fn(Vec<Value>) -> Result<Value, String>),
                ("isstring", conversion::isstring as fn(Vec<Value>) -> Result<Value, String>),
                ("islist", conversion::islist as fn(Vec<Value>) -> Result<Value, String>),
                ("isdict", conversion::isdict as fn(Vec<Value>) -> Result<Value, String>),
                ("typeof", conversion::typeof_ as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = conversion_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define convert.{}", name));
            }
        }

        let fs_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("append", filesystem::append as fn(Vec<Value>) -> Result<Value, String>),
                ("copy", filesystem::copy as fn(Vec<Value>) -> Result<Value, String>),
                ("create", filesystem::create as fn(Vec<Value>) -> Result<Value, String>),
                ("delete", filesystem::delete as fn(Vec<Value>) -> Result<Value, String>),
                ("exists", filesystem::exists as fn(Vec<Value>) -> Result<Value, String>),
                ("move", filesystem::remove as fn(Vec<Value>) -> Result<Value, String>),
                ("read", filesystem::read as fn(Vec<Value>) -> Result<Value, String>),
                ("write", filesystem::write as fn(Vec<Value>) -> Result<Value, String>),
                ("filename", filesystem::filename as fn(Vec<Value>) -> Result<Value, String>),
                ("filepath", filesystem::filepath as fn(Vec<Value>) -> Result<Value, String>),
                ("folderexist", filesystem::folderexist as fn(Vec<Value>) -> Result<Value, String>),
                ("foldername", filesystem::foldername as fn(Vec<Value>) -> Result<Value, String>),
                ("folderpath", filesystem::folderpath as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getfileextension",
                    filesystem::getfileextension as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("getfiles", filesystem::getfiles as fn(Vec<Value>) -> Result<Value, String>),
                ("getfolders", filesystem::getfolders as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getlastmodifiedtime",
                    filesystem::getlastmodifiedtime as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "getparentdirectory",
                    filesystem::getparentdirectory as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("getfilesize", filesystem::getfilesize as fn(Vec<Value>) -> Result<Value, String>),
                ("getsub", filesystem::getsub as fn(Vec<Value>) -> Result<Value, String>),
                ("makefolder", filesystem::makefolder as fn(Vec<Value>) -> Result<Value, String>),
                ("movefolder", filesystem::movefolder as fn(Vec<Value>) -> Result<Value, String>),
                ("readcontent", filesystem::readcontent as fn(Vec<Value>) -> Result<Value, String>),
                ("readline", filesystem::readline as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = fs_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define fs.{}", name));
            }
        }

        let sqlite_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("connect", sqlite::sqliteconnect as fn(Vec<Value>) -> Result<Value, String>),
                ("numrows", sqlite::sqlite_numrows as fn(Vec<Value>) -> Result<Value, String>),
                ("query", sqlite::sqlite_query as fn(Vec<Value>) -> Result<Value, String>),
                ("fetchall", sqlite::sqlite_fetchall as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "fetchassoc",
                    sqlite::sqlite_fetchassoc as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("fetchrow", sqlite::sqlite_fetchrow as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "fetcharray",
                    sqlite::sqlite_fetcharray as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("insertid", sqlite::sqlite_insertid as fn(Vec<Value>) -> Result<Value, String>),
                ("close", sqlite::sqlite_close as fn(Vec<Value>) -> Result<Value, String>),
                ("commit", sqlite::sqlite_commit as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "begin_transaction",
                    sqlite::sqlite_begin_transaction as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("rollback", sqlite::sqlite_rollback as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "escape_string",
                    sqlite::sqlite_escape_string as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("error", sqlite::sqlite_error as fn(Vec<Value>) -> Result<Value, String>),
                ("version", sqlite::sqlite_version as fn(Vec<Value>) -> Result<Value, String>),
                ("create", sqlite::sqlite_create as fn(Vec<Value>) -> Result<Value, String>),
                ("fetchone", sqlite::sqlite_fetchone as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = sqlite_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define sqlite.{}", name));
            }
        }

        let mysql_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("connect", mysqli::mysqlconnect as fn(Vec<Value>) -> Result<Value, String>),
                ("numrows", mysqli::mysql_numrows as fn(Vec<Value>) -> Result<Value, String>),
                ("query", mysqli::mysql_query as fn(Vec<Value>) -> Result<Value, String>),
                ("fetchall", mysqli::mysql_fetchall as fn(Vec<Value>) -> Result<Value, String>),
                ("fetchassoc", mysqli::mysql_fetchassoc as fn(Vec<Value>) -> Result<Value, String>),
                ("fetchrow", mysqli::mysql_fetchrow as fn(Vec<Value>) -> Result<Value, String>),
                ("fetcharray", mysqli::mysql_fetcharray as fn(Vec<Value>) -> Result<Value, String>),
                ("insertid", mysqli::mysql_insertid as fn(Vec<Value>) -> Result<Value, String>),
                ("close", mysqli::mysql_close as fn(Vec<Value>) -> Result<Value, String>),
                ("commit", mysqli::mysql_commit as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "begin_transaction",
                    mysqli::mysql_begin_transaction as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("rollback", mysqli::mysql_rollback as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "escape_string",
                    mysqli::mysql_escape_string as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("error", mysqli::mysql_error as fn(Vec<Value>) -> Result<Value, String>),
                ("version", mysqli::mysql_version as fn(Vec<Value>) -> Result<Value, String>),
                ("create", mysqli::mysql_create as fn(Vec<Value>) -> Result<Value, String>),
                ("fetchone", mysqli::mysql_fetchone as fn(Vec<Value>) -> Result<Value, String>),
            ];

            let mut env_guard = mysql_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define mysql.{}", name));
            }
        }

        let socket_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("tcp_connect", socket::tcp_connect as fn(Vec<Value>) -> Result<Value, String>),
                ("tcp_send", socket::tcp_send as fn(Vec<Value>) -> Result<Value, String>),
                ("tcp_receive", socket::tcp_receive as fn(Vec<Value>) -> Result<Value, String>),
                ("tcp_close", socket::tcp_close as fn(Vec<Value>) -> Result<Value, String>),
                ("tcp_bind", socket::tcp_bind as fn(Vec<Value>) -> Result<Value, String>),
                ("tcp_listen", socket::tcp_listen as fn(Vec<Value>) -> Result<Value, String>),
                ("tcp_accept", socket::tcp_accept as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "tcp_accept_by_addr",
                    socket::tcp_accept_by_addr as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "tcp_listen_with_backlog",
                    socket::tcp_listen_with_backlog as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("udp_bind", socket::udp_bind as fn(Vec<Value>) -> Result<Value, String>),
                ("udp_send_to", socket::udp_send_to as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "udp_receive_from",
                    socket::udp_receive_from as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("tls_connect", socket::tls_connect as fn(Vec<Value>) -> Result<Value, String>),
                ("tls_listen", socket::tls_listen as fn(Vec<Value>) -> Result<Value, String>),
                ("tls_accept", socket::tls_accept as fn(Vec<Value>) -> Result<Value, String>),
                ("tls_send", socket::tls_send as fn(Vec<Value>) -> Result<Value, String>),
                ("tls_receive", socket::tls_receive as fn(Vec<Value>) -> Result<Value, String>),
                ("tls_close", socket::tls_close as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "set_nonblocking",
                    socket::set_nonblocking as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "set_nonblocking_global",
                    socket::set_nonblocking_global as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("gethostbyname", socket::gethostbyname as fn(Vec<Value>) -> Result<Value, String>),
                ("sendfile", socket::sendfile as fn(Vec<Value>) -> Result<Value, String>),
                ("receivefile", socket::receivefile as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = socket_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define socket.{}", name));
            }
        }

        let fetcher_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("connect", fetcher::fetch_connect as fn(Vec<Value>) -> Result<Value, String>),
                ("request", fetcher::fetch_request as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getresponse",
                    fetcher::fetch_getresponse as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "settimeout",
                    fetcher::fetch_settimeout as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("close", fetcher::fetch_close as fn(Vec<Value>) -> Result<Value, String>),
                ("get", fetcher::fetch_get as fn(Vec<Value>) -> Result<Value, String>),
                ("post", fetcher::fetch_post as fn(Vec<Value>) -> Result<Value, String>),
                ("put", fetcher::fetch_put as fn(Vec<Value>) -> Result<Value, String>),
                ("delete", fetcher::fetch_delete as fn(Vec<Value>) -> Result<Value, String>),
                ("head", fetcher::fetch_head as fn(Vec<Value>) -> Result<Value, String>),
                ("patch", fetcher::fetch_patch as fn(Vec<Value>) -> Result<Value, String>),
                ("options", fetcher::fetch_options as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getcookies",
                    fetcher::fetch_getcookies as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("setcookie", fetcher::fetch_setcookies as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "clearcookies",
                    fetcher::fetch_clearcookies as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("getjson", fetcher::fetch_getjson as fn(Vec<Value>) -> Result<Value, String>),
                ("gettext", fetcher::fetch_gettext as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = fetcher_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define requester.{}", name));
            }
        }

        let system_env = Arc::new(Mutex::new(Environment::new(None)));

        {
            let funcs = [
                ("getenv", system::get_env as fn(Vec<Value>) -> Result<Value, String>),
                ("setenv", system::set_env as fn(Vec<Value>) -> Result<Value, String>),
                ("currentdir", system::current_dir as fn(Vec<Value>) -> Result<Value, String>),
                ("changedir", system::change_dir as fn(Vec<Value>) -> Result<Value, String>),
                ("listdir", system::list_dir as fn(Vec<Value>) -> Result<Value, String>),
                ("readfile", system::read_file as fn(Vec<Value>) -> Result<Value, String>),
                ("writefile", system::write_file as fn(Vec<Value>) -> Result<Value, String>),
                ("deletefile", system::delete_file as fn(Vec<Value>) -> Result<Value, String>),
                ("createdir", system::create_dir as fn(Vec<Value>) -> Result<Value, String>),
                ("deletedir", system::delete_dir as fn(Vec<Value>) -> Result<Value, String>),
                ("rename", system::rename as fn(Vec<Value>) -> Result<Value, String>),
                ("copyfile", system::copy_file as fn(Vec<Value>) -> Result<Value, String>),
                ("iswindows", system::is_windows as fn(Vec<Value>) -> Result<Value, String>),
                ("islinux", system::is_linux as fn(Vec<Value>) -> Result<Value, String>),
                ("ismacos", system::is_macos as fn(Vec<Value>) -> Result<Value, String>),
                ("isandroid", system::is_android as fn(Vec<Value>) -> Result<Value, String>),
                ("isios", system::is_ios as fn(Vec<Value>) -> Result<Value, String>),
                ("listvolumes", system::list_volumes as fn(Vec<Value>) -> Result<Value, String>),
                ("listdrives", system::list_drives as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "isappinstalled",
                    system::is_app_installed as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("joinpath", system::join_path as fn(Vec<Value>) -> Result<Value, String>),
                ("splitdrive", system::split_drive as fn(Vec<Value>) -> Result<Value, String>),
                ("splitpath", system::split_path as fn(Vec<Value>) -> Result<Value, String>),
                ("getprocessid", system::get_process_id as fn(Vec<Value>) -> Result<Value, String>),
                ("runcommand", system::run_command as fn(Vec<Value>) -> Result<Value, String>),
                ("spawnprocess", system::spawn_process as fn(Vec<Value>) -> Result<Value, String>),
                ("killprocess", system::kill_process as fn(Vec<Value>) -> Result<Value, String>),
                ("isfile", system::is_file as fn(Vec<Value>) -> Result<Value, String>),
                ("isdir", system::is_dir as fn(Vec<Value>) -> Result<Value, String>),
                ("gettree", system::get_tree as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getsysteminfo",
                    system::get_system_info as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("sleep", system::sleep as fn(Vec<Value>) -> Result<Value, String>),
                ("getpublicip", system::get_public_ip as fn(Vec<Value>) -> Result<Value, String>),
                ("getprivateip", system::get_private_ip as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getmacaddress",
                    system::get_mac_address as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("isportopen", system::is_port_open as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "listopenports",
                    system::list_open_ports as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("ping", system::ping as fn(Vec<Value>) -> Result<Value, String>),
            ];

            let mut env_guard = system_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define system function '{}'", name));
            }
        }

        let thread_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("run", thread_spawn_wrapper as fn(Vec<Value>) -> Result<Value, String>),
                ("join", thread::thread_join as fn(Vec<Value>) -> Result<Value, String>),
                ("sleep", thread::thread_sleep as fn(Vec<Value>) -> Result<Value, String>),
            ];
            let mut env_guard = thread_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define thread function '{}'", name));
            }
        }

        let mpl_env = std::sync::Arc::new(std::sync::Mutex::new(Environment::new(None)));

        {
            let funcs = [
                // Figure and Axes Management
                ("figure", mpl_figure as fn(Vec<Value>) -> Result<Value, String>),
                ("title", mpl_title as fn(Vec<Value>) -> Result<Value, String>),
                ("xlabel", mpl_xlabel as fn(Vec<Value>) -> Result<Value, String>),
                ("ylabel", mpl_ylabel as fn(Vec<Value>) -> Result<Value, String>),
                ("legend", mpl_legend as fn(Vec<Value>) -> Result<Value, String>),
                ("grid", mpl_grid as fn(Vec<Value>) -> Result<Value, String>),
                ("clear", mpl_clear as fn(Vec<Value>) -> Result<Value, String>),
                ("subplots", mpl_subplots as fn(Vec<Value>) -> Result<Value, String>),

                // Basic Plotting Functions
                ("plot", mpl_plot as fn(Vec<Value>) -> Result<Value, String>),
                ("scatter", mpl_scatter as fn(Vec<Value>) -> Result<Value, String>),
                ("histogram", mpl_hist as fn(Vec<Value>) -> Result<Value, String>),
                ("bar", mpl_bar as fn(Vec<Value>) -> Result<Value, String>),
                ("pie", mpl_pie as fn(Vec<Value>) -> Result<Value, String>),

                // Advanced and Specialized Charts
                ("step", mpl_step as fn(Vec<Value>) -> Result<Value, String>),
                ("violin", mpl_violin as fn(Vec<Value>) -> Result<Value, String>),
                ("stem", mpl_stem as fn(Vec<Value>) -> Result<Value, String>),
                ("bubble", mpl_bubble as fn(Vec<Value>) -> Result<Value, String>),
                ("stackedbar", mpl_stackedbar as fn(Vec<Value>) -> Result<Value, String>),
                ("polar", mpl_polar as fn(Vec<Value>) -> Result<Value, String>),
                ("candlestick", mpl_candlestick as fn(Vec<Value>) -> Result<Value, String>),
                ("radar", mpl_radar as fn(Vec<Value>) -> Result<Value, String>),
                ("waterfall", mpl_waterfall as fn(Vec<Value>) -> Result<Value, String>),
                ("area", mpl_area as fn(Vec<Value>) -> Result<Value, String>),
                ("boxplot", mpl_boxplot as fn(Vec<Value>) -> Result<Value, String>),
                ("heatmap", mpl_heatmap as fn(Vec<Value>) -> Result<Value, String>),
                ("contour", mpl_contour as fn(Vec<Value>) -> Result<Value, String>),
                ("errorbar", mpl_errorbar as fn(Vec<Value>) -> Result<Value, String>),
                ("quiver", mpl_quiver as fn(Vec<Value>) -> Result<Value, String>),
                ("savefig", mpl_savefig as fn(Vec<Value>) -> Result<Value, String>),
                ("showplot", mpl_show as fn(Vec<Value>) -> Result<Value, String>),
                ("showimage", mpl_showimage as fn(Vec<Value>) -> Result<Value, String>),
            ];

            let mut env_guard = mpl_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define function: {}", name));
            }
        }

        let gui_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("form", createform as fn(Vec<Value>) -> Result<Value, String>),
                ("listbox", createlistbox as fn(Vec<Value>) -> Result<Value, String>),
                ("combobox", createcombobox as fn(Vec<Value>) -> Result<Value, String>),
                ("button", createbutton as fn(Vec<Value>) -> Result<Value, String>),
                ("textbox", createtextbox as fn(Vec<Value>) -> Result<Value, String>),
                ("checkbox", createcheckbox as fn(Vec<Value>) -> Result<Value, String>),
                ("radiobox", createradiobox as fn(Vec<Value>) -> Result<Value, String>),
                ("label", createlabel as fn(Vec<Value>) -> Result<Value, String>),
                ("runapp", runapp as fn(Vec<Value>) -> Result<Value, String>),
                ("setresizable", set_resizable as fn(Vec<Value>) -> Result<Value, String>),
                ("startposition", set_startposition as fn(Vec<Value>) -> Result<Value, String>),
                ("setfullscreen", set_fullscreen as fn(Vec<Value>) -> Result<Value, String>),
                ("setposition", set_position as fn(Vec<Value>) -> Result<Value, String>),
                ("setmaximized", set_maximized as fn(Vec<Value>) -> Result<Value, String>),
                ("getmaximized", get_maximized as fn(Vec<Value>) -> Result<Value, String>),
                ("setborder", set_border as fn(Vec<Value>) -> Result<Value, String>),
                ("getborder", get_border as fn(Vec<Value>) -> Result<Value, String>),
                ("showform", show_form as fn(Vec<Value>) -> Result<Value, String>),
                ("hideform", hide_form as fn(Vec<Value>) -> Result<Value, String>),
                ("exit", exit as fn(Vec<Value>) -> Result<Value, String>),
                ("restore", restore_form as fn(Vec<Value>) -> Result<Value, String>),
                ("getfullscreen", get_fullscreen as fn(Vec<Value>) -> Result<Value, String>),
                ("getstartposition", get_startposition as fn(Vec<Value>) -> Result<Value, String>),
                ("setautosize", set_autosize as fn(Vec<Value>) -> Result<Value, String>),
                ("getautosize", get_autosize as fn(Vec<Value>) -> Result<Value, String>),
                ("getresizable", get_resizable as fn(Vec<Value>) -> Result<Value, String>),
                ("closeform", close_form as fn(Vec<Value>) -> Result<Value, String>),
                ("setleft", set_left as fn(Vec<Value>) -> Result<Value, String>),
                ("setright", set_right as fn(Vec<Value>) -> Result<Value, String>),
                ("setbelow", set_below as fn(Vec<Value>) -> Result<Value, String>),
                ("setabove", set_above as fn(Vec<Value>) -> Result<Value, String>),
                ("setx", set_x as fn(Vec<Value>) -> Result<Value, String>),
                ("getx", get_x as fn(Vec<Value>) -> Result<Value, String>),
                ("sety", set_y as fn(Vec<Value>) -> Result<Value, String>),
                ("gety", get_y as fn(Vec<Value>) -> Result<Value, String>),
                ("setwidth", set_width as fn(Vec<Value>) -> Result<Value, String>),
                ("getwidth", get_width as fn(Vec<Value>) -> Result<Value, String>),
                ("setheight", set_height as fn(Vec<Value>) -> Result<Value, String>),
                ("getheight", get_height as fn(Vec<Value>) -> Result<Value, String>),
                ("setfontsize", set_fontsize as fn(Vec<Value>) -> Result<Value, String>),
                ("getfontsize", get_fontsize as fn(Vec<Value>) -> Result<Value, String>),
                ("setfontname", set_fontname as fn(Vec<Value>) -> Result<Value, String>),
                ("getfontname", get_fontname as fn(Vec<Value>) -> Result<Value, String>),
                ("setfontweight", set_fontweight as fn(Vec<Value>) -> Result<Value, String>),
                ("getfontweight", get_fontweight as fn(Vec<Value>) -> Result<Value, String>),
                ("setbackcolor", set_backcolor as fn(Vec<Value>) -> Result<Value, String>),
                ("getbackcolor", get_backcolor as fn(Vec<Value>) -> Result<Value, String>),
                ("settextcolor", set_forecolor as fn(Vec<Value>) -> Result<Value, String>),
                ("gettextcolor", get_forecolor as fn(Vec<Value>) -> Result<Value, String>),
                ("setmargin", set_margin as fn(Vec<Value>) -> Result<Value, String>),
                ("setpadding", set_padding as fn(Vec<Value>) -> Result<Value, String>),
                ("settextalignment", set_text_alignment as fn(Vec<Value>) -> Result<Value, String>),
                ("settext", settext as fn(Vec<Value>) -> Result<Value, String>),
                ("gettext", gettext as fn(Vec<Value>) -> Result<Value, String>),
                ("setdock", setdock as fn(Vec<Value>) -> Result<Value, String>),
                ("getdock", getdock as fn(Vec<Value>) -> Result<Value, String>),
                ("setvisibility", setvisibility as fn(Vec<Value>) -> Result<Value, String>),
                ("getvisibility", getvisibility as fn(Vec<Value>) -> Result<Value, String>),
                ("setclickhandler", setclickhandler as fn(Vec<Value>) -> Result<Value, String>),
                ("getcursor", get_cursor as fn(Vec<Value>) -> Result<Value, String>),
                ("setcursor", set_cursor as fn(Vec<Value>) -> Result<Value, String>),
                ("getenabled", getenabled as fn(Vec<Value>) -> Result<Value, String>),
                ("setenabled", setenabled as fn(Vec<Value>) -> Result<Value, String>),
                ("getmultiline", get_multiline as fn(Vec<Value>) -> Result<Value, String>),
                ("setmultiline", set_multiline as fn(Vec<Value>) -> Result<Value, String>),
                ("setchecked", setchecked as fn(Vec<Value>) -> Result<Value, String>),
                ("getchecked", getchecked as fn(Vec<Value>) -> Result<Value, String>),
                ("groupbox", creategroupbox as fn(Vec<Value>) -> Result<Value, String>),
                ("card", createcard as fn(Vec<Value>) -> Result<Value, String>),
                ("sidebar", createsidebar as fn(Vec<Value>) -> Result<Value, String>),
                ("panel", createpanel as fn(Vec<Value>) -> Result<Value, String>),
                ("addto", add_to_container as fn(Vec<Value>) -> Result<Value, String>),
                ("getselectedindex", get_selected_index as fn(Vec<Value>) -> Result<Value, String>),
                ("setselectedindex", set_selected_index as fn(Vec<Value>) -> Result<Value, String>),
                ("getselectedtext", get_selected_text as fn(Vec<Value>) -> Result<Value, String>),
                ("setselectedtext", set_selected_text as fn(Vec<Value>) -> Result<Value, String>),
                ("page", createpages as fn(Vec<Value>) -> Result<Value, String>),
                ("picturebox", createpicturebox as fn(Vec<Value>) -> Result<Value, String>),
                ("progressbar", createprogressbar as fn(Vec<Value>) -> Result<Value, String>),
                ("scrollbar", createscrollbar as fn(Vec<Value>) -> Result<Value, String>),
                ("setmax", setmax as fn(Vec<Value>) -> Result<Value, String>),
                ("addtopage", add_to_page as fn(Vec<Value>) -> Result<Value, String>),
                ("additem", additem as fn(Vec<Value>) -> Result<Value, String>),
                ("getitem", getitem as fn(Vec<Value>) -> Result<Value, String>),
                ("addpage", addpage as fn(Vec<Value>) -> Result<Value, String>),
                ("showpage", showpage as fn(Vec<Value>) -> Result<Value, String>),
                ("hidepage", hidepage as fn(Vec<Value>) -> Result<Value, String>),
                ("getpageindex", getpageindex as fn(Vec<Value>) -> Result<Value, String>),
                ("setscrollmax", setscrollmax as fn(Vec<Value>) -> Result<Value, String>),
                ("setscrollmin", setscrollmin as fn(Vec<Value>) -> Result<Value, String>),
                ("setscrollvalue", setscrollvalue as fn(Vec<Value>) -> Result<Value, String>),
                ("setsmallchange", setsmallchange as fn(Vec<Value>) -> Result<Value, String>),
                ("getscrollmax", getscrollmax as fn(Vec<Value>) -> Result<Value, String>),
                ("getscrollmin", getscrollmin as fn(Vec<Value>) -> Result<Value, String>),
                ("getscrollvalue", getscrollvalue as fn(Vec<Value>) -> Result<Value, String>),
                ("getsmallchange", getsmallchange as fn(Vec<Value>) -> Result<Value, String>),
                ("setlargechange", setlargechange as fn(Vec<Value>) -> Result<Value, String>),
                ("getlargechange", getlargechange as fn(Vec<Value>) -> Result<Value, String>),
                ("setimage", setimage as fn(Vec<Value>) -> Result<Value, String>),
                ("setsizemode", setsizemode as fn(Vec<Value>) -> Result<Value, String>),
                ("setbarcolor", setbarcolor as fn(Vec<Value>) -> Result<Value, String>),
                ("setbarstyle", setbarstyle as fn(Vec<Value>) -> Result<Value, String>),
                ("setpageindex", setpageindex as fn(Vec<Value>) -> Result<Value, String>),
                ("settransition", settransition as fn(Vec<Value>) -> Result<Value, String>),
                ("setvalue", setvalue as fn(Vec<Value>) -> Result<Value, String>),
                ("getbarcolor", getbarcolor as fn(Vec<Value>) -> Result<Value, String>),
                ("setmin", setmin as fn(Vec<Value>) -> Result<Value, String>),
                ("getmin", getmin as fn(Vec<Value>) -> Result<Value, String>),
                ("getmax", getmax as fn(Vec<Value>) -> Result<Value, String>),
                ("removepage", removepage as fn(Vec<Value>) -> Result<Value, String>),
                ("timer", createtimer as fn(Vec<Value>) -> Result<Value, String>),
                ("setinterval", settimerinterval as fn(Vec<Value>) -> Result<Value, String>),
                ("getinterval", gettimerinterval as fn(Vec<Value>) -> Result<Value, String>),
                ("settimerenabled", settimerenabled as fn(Vec<Value>) -> Result<Value, String>),
                ("gettimerenabled", gettimerenabled as fn(Vec<Value>) -> Result<Value, String>),
                ("starttimer", starttimer as fn(Vec<Value>) -> Result<Value, String>),
                ("stoptimer", stoptimer as fn(Vec<Value>) -> Result<Value, String>),
                ("getvalue", getvalue as fn(Vec<Value>) -> Result<Value, String>),
                ("getbarstyle", getbarstyle as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "defaultpanel",
                    set_use_as_default_panel as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("alert", show_message_box as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getalertresult",
                    get_message_box_response as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("datepicker", createdatetimepicker as fn(Vec<Value>) -> Result<Value, String>),
                ("getdate", get_datetime as fn(Vec<Value>) -> Result<Value, String>),
                ("setdate", set_datetime as fn(Vec<Value>) -> Result<Value, String>),
                ("timepicker", createtimerpicker as fn(Vec<Value>) -> Result<Value, String>),
                ("gettime", get_timerpicker_time as fn(Vec<Value>) -> Result<Value, String>),
                ("settime", set_timerpicker_time as fn(Vec<Value>) -> Result<Value, String>),
                ("menu", createmenu as fn(Vec<Value>) -> Result<Value, String>),
                ("menuitem", add_menu_item as fn(Vec<Value>) -> Result<Value, String>),
                ("submenuitem", add_submenu_item as fn(Vec<Value>) -> Result<Value, String>),
                ("separator", add_separator_item as fn(Vec<Value>) -> Result<Value, String>),
                ("setmenuicon", set_menu_item_icon as fn(Vec<Value>) -> Result<Value, String>),
                ("getmenuicon", get_menu_item_icon as fn(Vec<Value>) -> Result<Value, String>),
                ("table", createtable as fn(Vec<Value>) -> Result<Value, String>),
                ("settabledata", set_table_data as fn(Vec<Value>) -> Result<Value, String>),
                ("gettabledata", get_table_data as fn(Vec<Value>) -> Result<Value, String>),
                ("openfiledialog", open_file_dialog as fn(Vec<Value>) -> Result<Value, String>),
                ("savefiledialog", save_file_dialog as fn(Vec<Value>) -> Result<Value, String>),
                ("folderdialog", folder_dialog as fn(Vec<Value>) -> Result<Value, String>),
                ("getdialogresult", get_dialog_result as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "setstartingpath",
                    set_dialog_startingpath as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("setdialogtitle", set_dialog_title as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "setmultiselect",
                    set_dialog_multiselect as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("setfilters", set_dialog_filters as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getstartingpath",
                    get_dialog_startingpath as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("getdialogtitle", get_dialog_title as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getmultiselect",
                    get_dialog_multiselect as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("getfilters", get_dialog_filters as fn(Vec<Value>) -> Result<Value, String>),
                ("colordialog", create_colordialog as fn(Vec<Value>) -> Result<Value, String>),
                ("showcolordialog", colordialog_show as fn(Vec<Value>) -> Result<Value, String>),
                ("getcolor", colordialog_get_color as fn(Vec<Value>) -> Result<Value, String>),
                ("imagebutton", create_imagebutton as fn(Vec<Value>) -> Result<Value, String>),
                ("treeview", create_treeview as fn(Vec<Value>) -> Result<Value, String>),
                ("nodeitem", treeview_add_node as fn(Vec<Value>) -> Result<Value, String>),
                ("getnodeitem", treeview_get_node as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "getselectednode",
                    treeview_get_selected as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "setselectednode",
                    treeview_set_selected as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("setnodeicon", treeview_set_node_icon as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "setnodecheckbox",
                    treeview_set_node_checkbox as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("treeviewevent", set_treeview_on_event as fn(Vec<Value>) -> Result<Value, String>),
                ("richtextbox", create_richtext as fn(Vec<Value>) -> Result<Value, String>),
                ("setformat", richtext_set_format as fn(Vec<Value>) -> Result<Value, String>),
                ("slider", create_slider as fn(Vec<Value>) -> Result<Value, String>),
                /*("numberbox", create_numberbox as fn(Vec<Value>) -> Result<Value, String>),
                ("setincrement", numberbox_set_increment as fn(Vec<Value>) -> Result<Value, String>),
                ("getincrement", numberbox_get_increment as fn(Vec<Value>) -> Result<Value, String>),
                ("setdecimals", numberbox_set_decimals as fn(Vec<Value>) -> Result<Value, String>),
                ("getdecimals", numberbox_get_decimals as fn(Vec<Value>) -> Result<Value, String>),*/
                ("toolbar", create_toolbar as fn(Vec<Value>) -> Result<Value, String>),
                ("toolbaritem", toolbar_add_item as fn(Vec<Value>) -> Result<Value, String>),
                ("statusbar", create_statusbar as fn(Vec<Value>) -> Result<Value, String>),
                ("shape", createshape as fn(Vec<Value>) -> Result<Value, String>),
                ("uiseparator", createseparator as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "setorintation",
                    setseparatororientation as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "getorintation",
                    getseparatororientation as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("gridlayout", creategridlayout as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "showgridlines",
                    setgridlayoutshowlines as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("getgridlines", getgridlayoutshowlines as fn(Vec<Value>) -> Result<Value, String>),
                ("setlayoutrows", setgridlayoutrows as fn(Vec<Value>) -> Result<Value, String>),
                ("getlayoutrows", getgridlayoutrows as fn(Vec<Value>) -> Result<Value, String>),
                ("setlayoutrow", addgridlayoutrow as fn(Vec<Value>) -> Result<Value, String>),
                ("setlayoutcolumn", addgridlayoutcolumn as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "setlayoutcolumns",
                    setgridlayoutcolumns as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "getlayoutcolumns",
                    getgridlayoutcolumns as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("setlayoutcells", setgridlayoutcell as fn(Vec<Value>) -> Result<Value, String>),
                ("flowlayout", createflowlayout as fn(Vec<Value>) -> Result<Value, String>),
                ("verticallayout", createverticallayout as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "horizontallayout",
                    createhorizontallayout as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("setspacing", setspacing as fn(Vec<Value>) -> Result<Value, String>),
                ("getspacing", getspacing as fn(Vec<Value>) -> Result<Value, String>),
                ("beginfill", drawy_begin_fill as fn(Vec<Value>) -> Result<Value, String>),
                ("endfill", drawy_end_fill as fn(Vec<Value>) -> Result<Value, String>),
                ("circle", drawy_circle as fn(Vec<Value>) -> Result<Value, String>),
                ("forward", drawy_forward as fn(Vec<Value>) -> Result<Value, String>),
                ("speed", drawy_speed as fn(Vec<Value>) -> Result<Value, String>),
                ("towardleft", drawy_left as fn(Vec<Value>) -> Result<Value, String>),
                ("towardright", drawy_right as fn(Vec<Value>) -> Result<Value, String>),
                ("goto", drawy_goto as fn(Vec<Value>) -> Result<Value, String>),
                ("penup", drawy_penup as fn(Vec<Value>) -> Result<Value, String>),
                ("pendown", drawy_pendown as fn(Vec<Value>) -> Result<Value, String>),
                ("pencolor", drawy_pencolor as fn(Vec<Value>) -> Result<Value, String>),
                /*("button", add_button as fn(Vec<Value>) -> Result<Value, String>), */
            ];
            let mut env_guard = gui_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define GUI function '{}'", name));
            }
        }

        let listener_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let funcs = [
                ("bind", listener::listener_bind as fn(Vec<Value>) -> Result<Value, String>),
                ("listen", listener::listener_listen as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "start_server",
                    listener::listener_start_server as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "serve_forever",
                    listener::listener_serve_forever as fn(Vec<Value>) -> Result<Value, String>,
                ),
                ("accept", listener::listener_accept as fn(Vec<Value>) -> Result<Value, String>),
                ("join", listener::listener_join as fn(Vec<Value>) -> Result<Value, String>),
                (
                    "response",
                    listener::listener_send_response as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "readrequest",
                    listener::listener_read_request as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "shutdown",
                    listener::listener_shutdown as fn(Vec<Value>) -> Result<Value, String>,
                ),
                (
                    "clientinfo",
                    listener::listener_client_info as fn(Vec<Value>) -> Result<Value, String>,
                ),
            ];
            let mut env_guard = listener_env.lock().unwrap();
            for (name, func) in funcs.iter() {
                env_guard
                    .define(name.to_string(), Value::BuiltinFunction(*func))
                    .expect(&format!("Failed to define listener.{}", name));
            }
        }

        static GLOBAL_INTERPRETER: Lazy<Arc<Mutex<Interpreter>>> = Lazy::new(|| {
            Arc::new(Mutex::new(Interpreter::new()))
        });

        // Helper function to retrieve the global interpreter.
        pub fn get_interpreter() -> Arc<Mutex<Interpreter>> {
            GLOBAL_INTERPRETER.clone()
        }
        fn thread_spawn_wrapper(args: Vec<Value>) -> Result<Value, String> {
            let interpreter = GLOBAL_INTERPRETER.clone();
            thread::thread_spawn(args, interpreter)
        }

        {
            let mut modules_guard = interpreter.modules.lock().unwrap();
            modules_guard.insert("math".to_string(), math_env);
            modules_guard.insert("string".to_string(), string_env);
            modules_guard.insert("array".to_string(), array_env);
            modules_guard.insert("dict".to_string(), dict_env);
            modules_guard.insert("datetime".to_string(), datetime_env);
            modules_guard.insert("convert".to_string(), conversion_env);
            modules_guard.insert("fs".to_string(), fs_env);
            modules_guard.insert("sqlite".to_string(), sqlite_env);
            modules_guard.insert("mysql".to_string(), mysql_env);
            modules_guard.insert("socket".to_string(), socket_env);
            modules_guard.insert("requester".to_string(), fetcher_env);
            modules_guard.insert("listener".to_string(), listener_env);
            modules_guard.insert("system".to_string(), system_env);
            modules_guard.insert("thread".to_string(), thread_env);
            modules_guard.insert("gui".to_string(), gui_env);
            modules_guard.insert("plotter".to_string(), mpl_env);
        }

        interpreter
    }

    pub fn interpret(&mut self, ast: &ASTNode) -> Result<Value, String> {
        let global_env = Arc::new(Mutex::new(Environment::new(None)));
        {
            let mut env_guard = global_env.lock().unwrap();
            env_guard
                .define("input".to_string(), Value::BuiltinFunction(Self::builtin_input))
                .expect("Failed to define built-in function 'input'");
        }
        CURRENT_ENV.with(|env| {
            *env.borrow_mut() = Some(global_env.clone());
        });
        let mut env = global_env;
        let result = match self.visit(ast, &mut env)? {
            ControlFlow::Normal(value) => Ok(value),
            ControlFlow::Return(value) => Ok(value),
            ControlFlow::Break => Err("Break outside loop".to_string()),
            ControlFlow::Continue => Err("Continue outside loop".to_string()),
            ControlFlow::Throw(e) => Err(format!("Uncaught exception: {:?}", e.to_string())),
            ControlFlow::Yield(_) => Err("Yield outside generator".to_string()),
        };
        CURRENT_ENV.with(|env| {
            *env.borrow_mut() = None;
        });

        result
    }

    pub fn visit(
        &mut self,
        node: &ASTNode,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        match node {
            ASTNode::Block { statements, .. } => self.visit_block(statements, env),
            ASTNode::Declaration { names, line, column } =>
                self.visit_declaration(names, *line, *column, env),
            ASTNode::SetStatement { target, value, line, column } =>
                self.visit_set_statement(target, value, *line, *column, env),
            ASTNode::AssignStatement { target, value, line, column } =>
                self.visit_assign_statement(target, value, *line, *column, env),
            ASTNode::IfStatement { condition, then_body, elseif_clauses, else_body, .. } => {
                self.visit_if_statement(condition, then_body, elseif_clauses, else_body, env)
            }
            ASTNode::InputStatement { target, prompt, line, column } =>
                self.visit_input_statement(target, prompt, *line, *column, env),
            ASTNode::ForStatement { variable, start, end, step, body, .. } => {
                self.visit_for_statement(variable, start, end, step, body, env)
            }
            ASTNode::ForeachStatement { variables, iterable, body, line, column } => {
                self.visit_foreach_statement(variables, iterable, body, *line, *column, env)
            }
            ASTNode::GenerateStatement { variable, start, end, by, body, .. } => {
                self.visit_generate_statement(variable, start, end, by, body, env)
            }
            ASTNode::ShowStatement { expr, .. } => self.visit_show_statement(expr, env),
            ASTNode::RepeatStatement { condition, body, .. } =>
                self.visit_repeat_statement(condition, body, env),
            ASTNode::RepeatTimeStatement { times, body, .. } =>
                self.visit_repeat_time_statement(times, body, env),
            ASTNode::ShowLnStatement { .. } => self.visit_showln_statement(),
            ASTNode::IterateStatement { variable, iterable, body, .. } => {
                self.visit_iterate_statement(variable, iterable, body, env)
            }
            ASTNode::ChooseStatement { expr, when_clauses, default, .. } => {
                self.visit_choose_statement(expr, when_clauses, default, env)
            }
            ASTNode::FunctionDecl { name, params, body, .. } =>
                self.visit_function_decl(name, params, body, env),
            ASTNode::FunctionCall { name, args, line, column } =>
                self.visit_function_call(name, args, *line, *column, env),
            ASTNode::ReturnStatement { value, .. } => self.visit_return_statement(value, env),
            ASTNode::ClassDecl { name, inherit, body, .. } =>
                self.visit_class_decl(name, inherit, body, env),
            ASTNode::MethodCall { object, method, args, line, column } => {
                self.visit_method_call(object, method, args, *line, *column, env)
            }
            ASTNode::ImportStatement { modules, line, column } =>
                self.visit_import_statement(modules, *line, *column, env),
            ASTNode::FromImportStatement { module, imported, line, column } => {
                self.visit_from_import_statement(module, imported, *line, *column, env)
            }
            ASTNode::RaiseException { error, line, column } =>
                self.visit_raise_exception(error, *line, *column, env),
            ASTNode::TryCapture { try_body, capture_var, capture_body, .. } => {
                self.visit_try_capture(try_body, capture_var, capture_body, env)
            }
            ASTNode::SkipStatement { .. } => Ok(ControlFlow::Continue),
            ASTNode::ExitStatement { .. } => Ok(ControlFlow::Break),
            ASTNode::AwaitStatement { expr, line, column } =>
                self.visit_await_statement(expr, *line, *column, env),
            ASTNode::FieldAccess { object, field, line, column } =>
                self.visit_field_access(object, field, *line, *column, env),
            ASTNode::ParentMethodAccess { method, args, line, column } => {
                self.visit_parent_method_access(method, args, *line, *column, env)
            }
            ASTNode::ParentAccess { field, line, column } =>
                self.visit_parent_access(field, *line, *column, env),
            ASTNode::Callback { name, params, line, column } =>
                self.visit_callback(name, params, *line, *column, env),
            ASTNode::Ternary { condition, then_expr, else_expr, line, column } => {
                self.visit_ternary(condition, then_expr, else_expr, *line, *column, env)
            }
            ASTNode::BinaryOperation { left, operator, right, line, column } => {
                self.visit_binary_operation(left, operator, right, *line, *column, env)
            }
            ASTNode::UnaryOperation { operator, expr, line, column } => {
                self.visit_unary_operation(operator, expr, *line, *column, env)
            }
            ASTNode::ArrayElement { elements, line, column } =>
                self.visit_array_element(elements, *line, *column, env),
            ASTNode::ArrayAccess { name, indices, line, column } =>
                self.visit_array_access(name, indices, *line, *column, env),
            ASTNode::Dictionary { pairs, line, column } =>
                self.visit_dictionary(pairs, *line, *column, env),
            ASTNode::DictionaryAccess { name, keys, line, column } =>
                self.visit_dictionary_access(name, keys, *line, *column, env),
            ASTNode::ClassInstantiation { args, line, column, class_expr } => {
                self.visit_class_instantiation(class_expr, args, *line, *column, env)
            }
            ASTNode::ByteArray { args, line, column } =>
                self.visit_byte_array(args, *line, *column, env),
            ASTNode::NumberLiteral { value, .. } => Ok(ControlFlow::Normal(Value::Number(*value))),
            ASTNode::StringLiteral { value, .. } =>
                Ok(ControlFlow::Normal(Value::String(value.clone()))),
            ASTNode::HexLiteral { value, line, column } =>
                self.visit_hex_literal(value, *line, *column, env),
            ASTNode::BytesLiteral { value, line, column } =>
                self.visit_bytes_literal(value, *line, *column, env),
            ASTNode::ScientificLiteral { value, .. } =>
                Ok(ControlFlow::Normal(Value::Number(*value))),
            ASTNode::Identifier { name, line, column } =>
                self.visit_identifier(name, *line, *column, env),
            ASTNode::True { .. } => Ok(ControlFlow::Normal(Value::Bool(true))),
            ASTNode::False { .. } => Ok(ControlFlow::Normal(Value::Bool(false))),
            ASTNode::Null { .. } => Ok(ControlFlow::Normal(Value::Null)),
            ASTNode::FieldDecl { modifier, decl, line, column } => {
                self.visit_field_decl(modifier, decl, *line, *column, env)
            }
            ASTNode::MethodDecl { modifier, name, params, body, line, column } => {
                self.visit_method_decl(modifier, name, params, body, *line, *column, env)
            }
            ASTNode::ConstructorDecl { modifier, params, body, line, column } => {
                self.visit_constructor_decl(modifier, params, body, *line, *column, env)
            }
            ASTNode::ParentConstructorCall { args, line, column } => {
                self.visit_parent_constructor_call(args, *line, *column, env)
            }
            ASTNode::EOF => Ok(ControlFlow::Normal(Value::Null)),
            ASTNode::This { line, column } => todo!(),
        }
    }

    pub fn visit_block(
        &mut self,
        statements: &[ASTNode],
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let mut result = ControlFlow::Normal(Value::Null);
        for stmt in statements {
            result = self.visit(stmt, env)?;
            match result {
                ControlFlow::Normal(_) => {}
                _ => {
                    return Ok(result);
                }
            }
        }
        Ok(result)
    }

    fn visit_declaration(
        &mut self,
        names: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        for name in names {
            match &**name {
                ASTNode::Identifier { name, .. } => {
                    env.lock().unwrap().define(name.clone(), Value::Null)?;
                }
                ASTNode::ArrayAccess { name, indices, .. } => {
                    let dims: Vec<usize> = indices
                        .iter()
                        .map(|idx| self.evaluate_to_number(idx, env).map(|n| n as usize))
                        .collect::<Result<Vec<_>, _>>()?;
                    let array = self.create_array(&dims)?;
                    env.lock().unwrap().define(name.clone(), array)?;
                }
                _ => {
                    return Err(
                        format!(
                            "Name Error: Invalid declaration target at line {}, column {}",
                            line,
                            column
                        )
                    );
                }
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_set_statement(
        &mut self,
        target: &ASTNode,
        value: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let val = self.evaluate(value, env)?;
        match target {
            // Variable or field assignment: set x to 5
            ASTNode::Identifier { name, .. } => {
                if let Some(obj) = &env.lock().unwrap().object {
                    let mut obj_guard = obj.lock().unwrap();
                    if let Value::Object { fields, .. } = &mut *obj_guard {
                        if fields.contains_key(name) {
                            // Update existing field in the object
                            fields.insert(name.clone(), Arc::new(Mutex::new(val)));
                            return Ok(ControlFlow::Normal(Value::Null));
                        }
                    }
                }
                // Reassign variable in the environment if not a field
                env.lock().unwrap().reassign(name.clone(), val)?;
            }
            // Array assignment: set arr[0] to 10
            ASTNode::ArrayAccess { name, indices, .. } => {
                let array = env.lock().unwrap().get(name)?;
                self.assign_array_element(&array, indices, val, line, column, env)?;
            }
            // New: Field assignment, e.g., set this.balance to 100
            ASTNode::FieldAccess { object, field, .. } => {
                if let ASTNode::Identifier { name: obj_name, .. } = &**object {
                    if obj_name == "this" {
                        // Access the current object via the environment
                        if let Some(obj) = &env.lock().unwrap().object {
                            let mut obj_guard = obj.lock().unwrap();
                            if let Value::Object { fields, .. } = &mut *obj_guard {
                                if let ASTNode::Identifier { name: field_name, .. } = &**field {
                                    // Update the specified field
                                    fields.insert(field_name.clone(), Arc::new(Mutex::new(val)));
                                    return Ok(ControlFlow::Normal(Value::Null));
                                } else {
                                    return Err(
                                        format!(
                                            "Field must be an identifier at line {}, column {}",
                                            line,
                                            column
                                        )
                                    );
                                }
                            } else {
                                return Err(
                                    format!(
                                        "Cannot set field on non-object at line {}, column {}",
                                        line,
                                        column
                                    )
                                );
                            }
                        } else {
                            return Err(
                                format!(
                                    "No 'this' object in context at line {}, column {}",
                                    line,
                                    column
                                )
                            );
                        }
                    } else {
                        // Optional: Handle setting fields on other objects (e.g., set obj.field to value)
                        let obj_val = self.evaluate(object, env)?;
                        if let Value::Object { mut fields, .. } = obj_val {
                            if let ASTNode::Identifier { name: field_name, .. } = &**field {
                                fields.insert(field_name.clone(), Arc::new(Mutex::new(val)));
                                return Ok(ControlFlow::Normal(Value::Null));
                            } else {
                                return Err(
                                    format!(
                                        "Field must be an identifier at line {}, column {}",
                                        line,
                                        column
                                    )
                                );
                            }
                        } else {
                            return Err(
                                format!(
                                    "Cannot set field on non-object at line {}, column {}",
                                    line,
                                    column
                                )
                            );
                        }
                    }
                } else {
                    return Err(
                        format!(
                            "Field access expects an object identifier at line {}, column {}",
                            line,
                            column
                        )
                    );
                }
            }
            _ => {
                return Err(format!("Invalid set target at line {}, column {}", line, column));
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_assign_statement(
        &mut self,
        target: &ASTNode,
        value: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let val = self.evaluate(value, env)?;
        match target {
            ASTNode::Identifier { name, .. } => {
                env.lock().unwrap().assign(name, val)?;
            }
            ASTNode::ArrayAccess { name, indices, .. } => {
                let array = env.lock().unwrap().get(name)?;
                self.assign_array_element(&array, indices, val, line, column, env)?;
            }
            ASTNode::FieldAccess { object, field, .. } => {
                if let ASTNode::Identifier { name: obj_name, .. } = &**object {
                    if obj_name == "this" {
                        if let Some(obj) = &env.lock().unwrap().object {
                            let mut obj_guard = obj.lock().unwrap();
                            if let Value::Object { fields, .. } = &mut *obj_guard {
                                if let ASTNode::Identifier { name: field_name, .. } = &**field {
                                    fields.insert(field_name.clone(), Arc::new(Mutex::new(val)));
                                    return Ok(ControlFlow::Normal(Value::Null));
                                } else {
                                    return Err(
                                        format!(
                                            "OOP Error: Field must be an identifier at line {}, column {}",
                                            line,
                                            column
                                        )
                                    );
                                }
                            } else {
                                return Err(
                                    format!(
                                        "OOP Error: Cannot access field on non-object at line {}, column {}",
                                        line,
                                        column
                                    )
                                );
                            }
                        } else {
                            return Err(
                                format!(
                                    "OOP Error: No 'this' object in context at line {}, column {}",
                                    line,
                                    column
                                )
                            );
                        }
                    }

                    let obj = env.lock().unwrap().get(obj_name)?;
                    let mut obj_guard = obj.lock().unwrap();
                    if let Value::Object { fields, .. } = &mut *obj_guard {
                        if let ASTNode::Identifier { name: field_name, .. } = &**field {
                            fields.insert(field_name.clone(), Arc::new(Mutex::new(val)));
                        } else {
                            return Err(
                                format!(
                                    "Field must be an identifier at line {}, column {}",
                                    line,
                                    column
                                )
                            );
                        }
                    } else {
                        return Err(
                            format!(
                                "Cannot assign field on non-object at line {}, column {}",
                                line,
                                column
                            )
                        );
                    }
                } else {
                    return Err(
                        format!(
                            "Field access expects an object identifier at line {}, column {}",
                            line,
                            column
                        )
                    );
                }
            }
            _ => {
                return Err(
                    format!("Invalid assignment target at line {}, column {}", line, column)
                );
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_if_statement(
        &mut self,
        condition: &ASTNode,
        then_body: &[ASTNode],
        elseif_clauses: &[(Box<ASTNode>, Vec<ASTNode>)],
        else_body: &Option<Vec<ASTNode>>,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        if self.evaluate_to_bool(condition, env)? {
            self.visit_block(then_body, env)
        } else {
            for (cond, body) in elseif_clauses {
                if self.evaluate_to_bool(cond, env)? {
                    return self.visit_block(body, env);
                }
            }
            if let Some(body) = else_body {
                self.visit_block(body, env)
            } else {
                Ok(ControlFlow::Normal(Value::Null))
            }
        }
    }

    fn visit_input_statement(
        &mut self,
        target: &ASTNode,
        prompt: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let prompt_val = self.evaluate(prompt, env)?;
        print!("{}", prompt_val.to_string());
        io
            ::stdout()
            .flush()
            .map_err(|e| e.to_string())?;
        let mut input = String::new();
        io
            ::stdin()
            .read_line(&mut input)
            .map_err(|e| e.to_string())?;
        let input_val = Value::String(input.trim().to_string());
        match target {
            ASTNode::Identifier { name, .. } => {
                env.lock().unwrap().define(name.clone(), input_val)?;
            }
            ASTNode::ArrayAccess { name, indices, .. } => {
                let array = env.lock().unwrap().get(name)?;
                self.assign_array_element(&array, indices, input_val, line, column, env)?;
            }
            _ => {
                return Err(format!("Invalid input target at line {}, column {}", line, column));
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_for_statement(
        &mut self,
        variable: &str,
        start: &ASTNode,
        end: &ASTNode,
        step: &Option<Box<ASTNode>>,
        body: &[ASTNode],
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let mut current = self.evaluate_to_number(start, env)?;
        let end_val = self.evaluate_to_number(end, env)?;
        let step_val = step.as_ref().map_or(Ok(1.0), |s| self.evaluate_to_number(s, env))?;
        let var_name = variable.to_string();

        if step_val > 0.0 {
            while current <= end_val {
                env.lock().unwrap().reassign(var_name.clone(), Value::Number(current))?;
                match self.visit_block(body, env)? {
                    ControlFlow::Normal(_) => {}
                    ControlFlow::Break => {
                        break;
                    }
                    ControlFlow::Continue => {}
                    other => {
                        return Ok(other);
                    }
                }
                current += step_val;
            }
        } else {
            while current >= end_val {
                env.lock().unwrap().reassign(var_name.clone(), Value::Number(current))?;
                match self.visit_block(body, env)? {
                    ControlFlow::Normal(_) => {}
                    ControlFlow::Break => {
                        break;
                    }
                    ControlFlow::Continue => {}
                    other => {
                        return Ok(other);
                    }
                }
                current += step_val;
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_foreach_statement(
        &mut self,
        variables: &[String],
        iterable: &ASTNode,
        body: &[ASTNode],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let iterable_val = self.evaluate(iterable, env)?;
        match iterable_val {
            Value::Array(arr) => {
                if variables.len() != 1 {
                    return Err(
                        format!(
                            "Type Error: Array iteration requires exactly one variable, got {} at line {}, column {}",
                            variables.len(),
                            line,
                            column
                        )
                    );
                }
                let var_name = &variables[0];
                for element in arr {
                    env
                        .lock()
                        .unwrap()
                        .reassign(var_name.clone(), element.lock().unwrap().clone())?;
                    match self.visit_block(body, env)? {
                        ControlFlow::Normal(_) => {}
                        ControlFlow::Break => {
                            break;
                        }
                        ControlFlow::Continue => {}
                        other => {
                            return Ok(other);
                        }
                    }
                }
            }
            Value::Dictionary(dict) => {
                match variables.len() {
                    1 => {
                        let key_var = &variables[0];
                        for key in dict.keys() {
                            env
                                .lock()
                                .unwrap()
                                .reassign(key_var.clone(), Value::String(key.clone()))?;
                            match self.visit_block(body, env)? {
                                ControlFlow::Normal(_) => {}
                                ControlFlow::Break => {
                                    break;
                                }
                                ControlFlow::Continue => {}
                                other => {
                                    return Ok(other);
                                }
                            }
                        }
                    }
                    2 => {
                        let key_var = &variables[0];
                        let value_var = &variables[1];
                        for (key, value) in dict {
                            env
                                .lock()
                                .unwrap()
                                .reassign(key_var.clone(), Value::String(key.clone()))?;
                            env
                                .lock()
                                .unwrap()
                                .reassign(value_var.clone(), value.lock().unwrap().clone())?;
                            match self.visit_block(body, env)? {
                                ControlFlow::Normal(_) => {}
                                ControlFlow::Break => {
                                    break;
                                }
                                ControlFlow::Continue => {}
                                other => {
                                    return Ok(other);
                                }
                            }
                        }
                    }
                    n => {
                        return Err(
                            format!(
                                "Type Error: Dictionary iteration requires 1 or 2 variables, got {} at line {}, column {}",
                                n,
                                line,
                                column
                            )
                        );
                    }
                }
            }
            _ => {
                return Err(
                    format!(
                        "Type Error: 'foreach' expects an array or dictionary, got {} at line {}, column {}",
                        iterable_val.to_string(),
                        line,
                        column
                    )
                );
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_generate_statement(
        &mut self,
        variable: &str,
        start: &ASTNode,
        end: &ASTNode,
        by: &Option<Box<ASTNode>>,
        body: &[ASTNode],
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let mut current = self.evaluate_to_number(start, env)?;
        let end_val = self.evaluate_to_number(end, env)?;
        let step_val = by.as_ref().map_or(Ok(1.0), |s| self.evaluate_to_number(s, env))?;
        while (if step_val > 0.0 { current <= end_val } else { current >= end_val }) {
            env.lock().unwrap().reassign(variable.to_string(), Value::Number(current))?;
            match self.visit_block(body, env)? {
                ControlFlow::Normal(_) => {}
                ControlFlow::Break => {
                    break;
                }
                ControlFlow::Continue => {}
                ControlFlow::Yield(value) => println!("{}", value.to_string()),
                other => {
                    return Ok(other);
                }
            }
            current += step_val;
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_show_statement(
        &mut self,
        expr: &ASTNode,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let value = self.evaluate(expr, env)?;
        println!("{}", value.to_string());
        io
            ::stdout()
            .flush()
            .map_err(|e| e.to_string())?;
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_repeat_statement(
        &mut self,
        condition: &ASTNode,
        body: &[ASTNode],
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        while self.evaluate_to_bool(condition, env)? {
            match self.visit_block(body, env)? {
                ControlFlow::Normal(_) => {}
                ControlFlow::Break => {
                    break;
                }
                ControlFlow::Continue => {}
                other => {
                    return Ok(other);
                }
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_repeat_time_statement(
        &mut self,
        times: &ASTNode,
        body: &[ASTNode],
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let times_val = self.evaluate_to_number(times, env)? as i64;
        if times_val < 0 {
            return Err("Repeat times must be non-negative".to_string());
        }
        for _ in 0..times_val {
            match self.visit_block(body, env)? {
                ControlFlow::Normal(_) => {}
                ControlFlow::Break => {
                    break;
                }
                ControlFlow::Continue => {}
                other => {
                    return Ok(other);
                }
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_showln_statement(&mut self) -> Result<ControlFlow, String> {
        println!();
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_iterate_statement(
        &mut self,
        variable: &str,
        iterable: &ASTNode,
        body: &[ASTNode],
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let iterable_val = self.evaluate(iterable, env)?;
        match iterable_val {
            Value::Array(arr) => {
                for element in arr {
                    env
                        .lock()
                        .unwrap()
                        .reassign(variable.to_string(), element.lock().unwrap().clone())?;
                    match self.visit_block(body, env)? {
                        ControlFlow::Normal(_) => {}
                        ControlFlow::Break => {
                            break;
                        }
                        ControlFlow::Continue => {}
                        other => {
                            return Ok(other);
                        }
                    }
                }
            }
            Value::Dictionary(dict) => {
                for (key, value) in dict {
                    env.lock().unwrap().reassign(variable.to_string(), Value::String(key.clone()))?;
                    env
                        .lock()
                        .unwrap()
                        .reassign(format!("{}_value", variable), value.lock().unwrap().clone())?;
                    match self.visit_block(body, env)? {
                        ControlFlow::Normal(_) => {}
                        ControlFlow::Break => {
                            break;
                        }
                        ControlFlow::Continue => {}
                        other => {
                            return Ok(other);
                        }
                    }
                }
            }
            _ => {
                return Err("Iterable must be an array or dictionary".to_string());
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_choose_statement(
        &mut self,
        expr: &ASTNode,
        when_clauses: &[(Box<ASTNode>, Vec<ASTNode>)],
        default: &Option<Vec<ASTNode>>,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let expr_val = self.evaluate(expr, env)?;
        for (cond, body) in when_clauses {
            let cond_val = self.evaluate(cond, env)?;
            if expr_val == cond_val {
                return self.visit_block(body, env);
            }
        }
        if let Some(body) = default {
            self.visit_block(body, env)
        } else {
            Ok(ControlFlow::Normal(Value::Null))
        }
    }

    fn visit_function_decl(
        &mut self,
        name: &str,
        params: &[Box<ASTNode>],
        body: &[ASTNode],
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let mut param_list = Vec::new();
        let mut has_default = false;
        for param in params {
            match &**param {
                ASTNode::Identifier { name, .. } => {
                    if has_default {
                        return Err(
                            "Param Error: Parameters with defaults must be after those without".to_string()
                        );
                    }
                    param_list.push((name.clone(), None));
                }
                ASTNode::AssignStatement { target, value, .. } => {
                    if let ASTNode::Identifier { name, .. } = &**target {
                        let default_val = self.evaluate(value, env)?;
                        param_list.push((name.clone(), Some(default_val)));
                        has_default = true;
                    } else {
                        return Err("Invalid parameter default".to_string());
                    }
                }
                _ => {
                    return Err("Invalid parameter".to_string());
                }
            }
        }
        let func = Value::Function {
            name: name.to_string(),
            params: param_list,
            body: body.to_vec(),
            closure: env.clone(),
            object: None,
        };
        env.lock().unwrap().define(name.to_string(), func)?;
        Ok(ControlFlow::Normal(Value::Null))
    }

    pub fn visit_function_call(
        &mut self,
        name: &str,
        args: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let func_val = env
            .lock()
            .unwrap()
            .get(name)
            .map_err(|_| {
                format!(
                    "Name Error: Function '{}' not found at line {}, column {}",
                    name,
                    line,
                    column
                )
            })?;
        let evaluated_args: Vec<Value> = args
            .iter()
            .map(|arg| self.evaluate(arg, env))
            .collect::<Result<Vec<_>, _>>()?;

        match &*func_val.lock().unwrap() {
            Value::Function { params, body, closure, object, .. } => {
                let required_params = params
                    .iter()
                    .filter(|p| p.1.is_none())
                    .count();
                if evaluated_args.len() < required_params || evaluated_args.len() > params.len() {
                    return Err(
                        format!(
                            "Name Error: Function '{}' expects at least {} and at most {} arguments, got {} at line {}, column {}",
                            name,
                            required_params,
                            params.len(),
                            evaluated_args.len(),
                            line,
                            column
                        )
                    );
                }
                let mut new_env = Arc::new(Mutex::new(Environment::new(Some(closure.clone()))));
                if let Some(obj) = object {
                    new_env.lock().unwrap().object = Some(obj.clone());
                    new_env
                        .lock()
                        .unwrap()
                        .define("this".to_string(), obj.lock().unwrap().clone())?;
                }
                for (i, (param_name, default)) in params.iter().enumerate() {
                    let arg_val = if i < evaluated_args.len() {
                        evaluated_args[i].clone()
                    } else {
                        default.clone().unwrap() // Safe: i >= required_params implies default exists
                    };
                    new_env.lock().unwrap().define(param_name.clone(), arg_val)?;
                }
                let mut local_env = new_env;
                let result = self.visit_block(body, &mut local_env)?;
                match result {
                    ControlFlow::Return(value) => Ok(ControlFlow::Normal(value)),
                    ControlFlow::Normal(_) => Ok(ControlFlow::Normal(Value::Null)),
                    other => Ok(other),
                }
            }
            Value::BuiltinFunction(func) => {
                let result = func(evaluated_args)?;
                Ok(ControlFlow::Normal(result))
            }
            _ =>
                Err(
                    format!(
                        "Type Error: '{}' is not a function at line {}, column {}",
                        name,
                        line,
                        column
                    )
                ),
        }
    }

    pub fn builtin_input(args: Vec<Value>) -> Result<Value, String> {
        let prompt = if !args.is_empty() {
            if let Value::String(s) = &args[0] {
                s.clone()
            } else {
                return Err("input() prompt must be a string".to_string());
            }
        } else {
            String::new()
        };
        print!("{}", prompt);
        io
            ::stdout()
            .flush()
            .map_err(|e| e.to_string())?;
        let mut input_line = String::new();
        io
            ::stdin()
            .read_line(&mut input_line)
            .map_err(|e| e.to_string())?;
        Ok(Value::String(input_line.trim_end().to_string()))
    }

    fn visit_return_statement(
        &mut self,
        value: &Option<Box<ASTNode>>,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let val = match value {
            Some(expr) => self.evaluate(expr, env)?,
            None => Value::Null,
        };
        Ok(ControlFlow::Return(val))
    }

    fn visit_class_decl(
        &mut self,
        name: &str,
        inherit: &Option<String>,
        body: &[ASTNode],
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let class_env = Arc::new(Mutex::new(Environment::new(Some(env.clone()))));
        for member in body {
            if
                let ASTNode::MethodDecl {
                    name: method_name,
                    params,
                    body: method_body,
                    ..
                } = member
            {
                let mut param_list = Vec::new();
                let mut has_default = false;

                // Process each parameter
                for param in params {
                    match &**param {
                        ASTNode::Identifier { name, .. } => {
                            // Parameter without default
                            if has_default {
                                return Err(
                                    "Parameters with defaults must come after those without".to_string()
                                );
                            }
                            param_list.push((name.clone(), None));
                        }
                        ASTNode::AssignStatement { target, value, .. } => {
                            // Parameter with default value
                            if let ASTNode::Identifier { name, .. } = &**target {
                                let default_val = self.evaluate(value, env)?;
                                param_list.push((name.clone(), Some(default_val)));
                                has_default = true;
                            } else {
                                return Err("Invalid parameter default".to_string());
                            }
                        }
                        _ => {
                            return Err("Invalid parameter".to_string());
                        }
                    }
                }

                // Define the method with the updated param_list
                let method = Value::Function {
                    name: method_name.to_string(),
                    params: param_list, // Now Vec<(String, Option<Value>)>
                    body: method_body.to_vec(),
                    closure: class_env.clone(),
                    object: None,
                };
                class_env.lock().unwrap().define(method_name.to_string(), method)?;
            }
        }

        // Define the class
        let class_value = Value::Class {
            ast: Box::new(ASTNode::ClassDecl {
                name: name.to_string(),
                inherit: inherit.clone(),
                body: body.to_vec(),
                line: 0,
                column: 0,
            }),
            env: class_env,
        };
        env.lock().unwrap().define(name.to_string(), class_value)?;
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_method_call(
        &mut self,
        object: &ASTNode,
        method: &str,
        args: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let obj_val = self.evaluate(object, env)?;
        let obj_arc = Arc::new(Mutex::new(obj_val.clone()));

        match obj_val {
            Value::String(s) => {
                let method_func = self.string_methods.get(method).cloned();
                if let Some(Value::BuiltinFunction(func)) = method_func {
                    let mut method_args = vec![Value::String(s)];
                    let arg_values: Result<Vec<Value>, String> = args
                        .iter()
                        .map(|arg| self.evaluate(arg, env))
                        .collect();
                    method_args.extend(arg_values?);
                    let result = func(method_args)?;
                    Ok(ControlFlow::Normal(result))
                } else if method_func.is_some() {
                    Err(
                        format!(
                            "Invalid method '{}' for string at line {}, column {}",
                            method,
                            line,
                            column
                        )
                    )
                } else {
                    Err(
                        format!(
                            "Method '{}' not found for string at line {}, column {}",
                            method,
                            line,
                            column
                        )
                    )
                }
            }
            Value::Array(arr) => {
                let method_func = self.array_methods.get(method).cloned();
                if let Some(Value::BuiltinFunction(func)) = method_func {
                    let mut method_args = vec![Value::Array(arr)];
                    let arg_values: Result<Vec<Value>, String> = args
                        .iter()
                        .map(|arg| self.evaluate(arg, env))
                        .collect();
                    method_args.extend(arg_values?);
                    let result = func(method_args)?;
                    Ok(ControlFlow::Normal(result))
                } else if method_func.is_some() {
                    Err(
                        format!(
                            "Invalid method '{}' for array at line {}, column {}",
                            method,
                            line,
                            column
                        )
                    )
                } else {
                    Err(
                        format!(
                            "Method '{}' not found for array at line {}, column {}",
                            method,
                            line,
                            column
                        )
                    )
                }
            }
            Value::Dictionary(dict) => {
                let method_func = self.dict_methods.get(method).cloned();
                if let Some(Value::BuiltinFunction(func)) = method_func {
                    let mut method_args = vec![Value::Dictionary(dict)];
                    let arg_values: Result<Vec<Value>, String> = args
                        .iter()
                        .map(|arg| self.evaluate(arg, env))
                        .collect();
                    method_args.extend(arg_values?);
                    let result = func(method_args)?;
                    Ok(ControlFlow::Normal(result))
                } else if method_func.is_some() {
                    Err(
                        format!(
                            "Invalid method '{}' for dictionary at line {}, column {}",
                            method,
                            line,
                            column
                        )
                    )
                } else {
                    Err(
                        format!(
                            "Method '{}' not found for dictionary at line {}, column {}",
                            method,
                            line,
                            column
                        )
                    )
                }
            }
            Value::Object { ref class, ref class_ast, ref module, .. } => {
                if let Some(module_name) = module {
                    let mod_env = {
                        let modules_guard = self.modules.lock().unwrap();
                        modules_guard.get(module_name).cloned()
                    };
                    if let Some(mod_env) = mod_env {
                        let method_val = mod_env
                            .lock()
                            .unwrap()
                            .get(method)
                            .map_err(|_| {
                                format!(
                                    "Method '{}' not found in module '{}' at line {}, column {}",
                                    method,
                                    module_name,
                                    line,
                                    column
                                )
                            })?;
                        match &*method_val.lock().unwrap() {
                            Value::BuiltinFunction(func) => {
                                let arg_values = args
                                    .iter()
                                    .map(|arg| self.evaluate(arg, env))
                                    .collect::<Result<Vec<_>, _>>()?;
                                let result = func(arg_values)?;
                                Ok(ControlFlow::Normal(result))
                            }
                            Value::Function { params, body, closure, .. } => {
                                // Count required parameters (those without defaults)
                                let required_params = params
                                    .iter()
                                    .filter(|p| p.1.is_none())
                                    .count();
                                if args.len() < required_params || args.len() > params.len() {
                                    return Err(
                                        format!(
                                            "Function '{}' expects at least {} and at most {} arguments, got {} at line {}, column {}",
                                            method,
                                            required_params,
                                            params.len(),
                                            args.len(),
                                            line,
                                            column
                                        )
                                    );
                                }
                                let mut new_env = Arc::new(
                                    Mutex::new(Environment::new(Some(closure.clone())))
                                );
                                let arg_values = args
                                    .iter()
                                    .map(|arg| self.evaluate(arg, env))
                                    .collect::<Result<Vec<_>, _>>()?;
                                for (i, (param_name, default)) in params.iter().enumerate() {
                                    let arg_val = if i < arg_values.len() {
                                        arg_values[i].clone()
                                    } else {
                                        default.clone().unwrap() // Safe: i >= required_params
                                    };
                                    new_env.lock().unwrap().define(param_name.clone(), arg_val)?;
                                }
                                let mut local_env = new_env;
                                let result = self.visit_block(body, &mut local_env)?;
                                match result {
                                    ControlFlow::Return(value) => Ok(ControlFlow::Normal(value)),
                                    ControlFlow::Normal(_) => Ok(ControlFlow::Normal(Value::Null)),
                                    other => Ok(other),
                                }
                            }
                            _ =>
                                Err(
                                    format!(
                                        "'{}' is not a function in module '{}' at line {}, column {}",
                                        method,
                                        module_name,
                                        line,
                                        column
                                    )
                                ),
                        }
                    } else {
                        Err(
                            format!(
                                "Module '{}' not found at line {}, column {}",
                                module_name,
                                line,
                                column
                            )
                        )
                    }
                } else {
                    // Handle class methods
                    if let ASTNode::ClassDecl { body, .. } = &**class_ast {
                        let method_info = body
                            .iter()
                            .find_map(|member| {
                                if let ASTNode::MethodDecl { name, params, body, .. } = member {
                                    if name == method {
                                        Some((params.clone(), body.clone()))
                                    } else {
                                        None
                                    }
                                } else {
                                    None
                                }
                            })
                            .ok_or_else(||
                                format!(
                                    "Method '{}' not found in class '{}' at line {}, column {}",
                                    method,
                                    class,
                                    line,
                                    column
                                )
                            )?;
                        let (params, method_body) = method_info;
                        // Process params to handle defaults
                        let mut param_list = Vec::new();
                        let mut has_default = false;
                        for param in params {
                            match &*param {
                                ASTNode::Identifier { name, .. } => {
                                    if has_default {
                                        return Err(
                                            "Parameters with defaults must come after those without".to_string()
                                        );
                                    }
                                    param_list.push((name.clone(), None));
                                }
                                ASTNode::AssignStatement { target, value, .. } => {
                                    if let ASTNode::Identifier { name, .. } = &**target {
                                        let default_val = self.evaluate(value, env)?;
                                        param_list.push((name.clone(), Some(default_val)));
                                        has_default = true;
                                    } else {
                                        return Err("Invalid parameter default".to_string());
                                    }
                                }
                                _ => {
                                    return Err("Invalid parameter".to_string());
                                }
                            }
                        }
                        // Count required parameters
                        let required_params = param_list
                            .iter()
                            .filter(|p| p.1.is_none())
                            .count();
                        if args.len() < required_params || args.len() > param_list.len() {
                            return Err(
                                format!(
                                    "Method '{}' expects at least {} and at most {} arguments, got {} at line {}, column {}",
                                    method,
                                    required_params,
                                    param_list.len(),
                                    args.len(),
                                    line,
                                    column
                                )
                            );
                        }
                        let mut new_env = Arc::new(Mutex::new(Environment::new(Some(env.clone()))));
                        new_env.lock().unwrap().object = Some(obj_arc.clone());
                        new_env.lock().unwrap().define("this".to_string(), obj_val.clone())?;
                        let arg_values = args
                            .iter()
                            .map(|arg| self.evaluate(arg, env))
                            .collect::<Result<Vec<_>, _>>()?;
                        for (i, (param_name, default)) in param_list.iter().enumerate() {
                            let arg_val = if i < arg_values.len() {
                                arg_values[i].clone()
                            } else {
                                default.clone().unwrap() // Safe: i >= required_params
                            };
                            new_env.lock().unwrap().define(param_name.clone(), arg_val)?;
                        }
                        let mut local_env = new_env;
                        let result = self.visit_block(&method_body, &mut local_env)?;
                        match result {
                            ControlFlow::Return(value) => Ok(ControlFlow::Normal(value)),
                            ControlFlow::Normal(_) => Ok(ControlFlow::Normal(Value::Null)),
                            other => Ok(other),
                        }
                    } else {
                        Err(
                            format!(
                                "Invalid class definition for '{}' at line {}, column {}",
                                class,
                                line,
                                column
                            )
                        )
                    }
                }
            }
            Value::Module { env: mod_env, name } => {
                let method_val = mod_env
                    .lock()
                    .unwrap()
                    .get(method)
                    .map_err(|_| {
                        format!(
                            "Attribute '{}' not found in module '{}' at line {}, column {}",
                            method,
                            name,
                            line,
                            column
                        )
                    })?;
                match &*method_val.lock().unwrap() {
                    Value::Function { params, body, closure, .. } => {
                        // Count required parameters (those without defaults)
                        let required_params = params
                            .iter()
                            .filter(|p| p.1.is_none())
                            .count();
                        if args.len() < required_params || args.len() > params.len() {
                            return Err(
                                format!(
                                    "Function '{}' expects at least {} and at most {} arguments, got {} at line {}, column {}",
                                    method,
                                    required_params,
                                    params.len(),
                                    args.len(),
                                    line,
                                    column
                                )
                            );
                        }
                        let mut new_env = Arc::new(
                            Mutex::new(Environment::new(Some(closure.clone())))
                        );
                        let arg_values = args
                            .iter()
                            .map(|arg| self.evaluate(arg, env))
                            .collect::<Result<Vec<_>, _>>()?;
                        for (i, (param_name, default)) in params.iter().enumerate() {
                            let arg_val = if i < arg_values.len() {
                                arg_values[i].clone()
                            } else {
                                default.clone().unwrap() // Safe: i >= required_params
                            };
                            new_env.lock().unwrap().define(param_name.clone(), arg_val)?;
                        }
                        let mut local_env = new_env;
                        let result = self.visit_block(body, &mut local_env)?;
                        match result {
                            ControlFlow::Return(value) => Ok(ControlFlow::Normal(value)),
                            ControlFlow::Normal(_) => Ok(ControlFlow::Normal(Value::Null)),
                            other => Ok(other),
                        }
                    }
                    Value::BuiltinFunction(func) => {
                        let arg_values = args
                            .iter()
                            .map(|arg| self.evaluate(arg, env))
                            .collect::<Result<Vec<_>, _>>()?;
                        let result = func(arg_values)?;
                        Ok(ControlFlow::Normal(result))
                    }
                    _ =>
                        Err(
                            format!(
                                "'{}' is not a function in module '{}' at line {}, column {}",
                                method,
                                name,
                                line,
                                column
                            )
                        ),
                }
            }
            _ =>
                Err(
                    format!(
                        "Method call on non-object/non-module at line {}, column {}",
                        line,
                        column
                    )
                ),
        }
    }

    fn visit_raise_exception(
        &mut self,
        error: &Option<Box<ASTNode>>,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let error_val = match error {
            Some(expr) => self.evaluate(expr, env)?,
            None => Value::Error("Unknown error".to_string()),
        };
        Ok(ControlFlow::Throw(error_val))
    }

    fn visit_try_capture(
        &mut self,
        try_body: &[ASTNode],
        capture_var: &str,
        capture_body: &[ASTNode],
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        match self.visit_block(try_body, env) {
            Ok(ControlFlow::Throw(error)) => {
                let mut new_env = Arc::new(Mutex::new(Environment::new(Some(env.clone()))));
                new_env.lock().unwrap().define(capture_var.to_string(), error)?;
                let mut local_env = new_env;
                let result = self.visit_block(capture_body, &mut local_env)?;
                Ok(result)
            }
            Ok(other) => Ok(other),
            Err(e) => Err(e),
        }
    }

    fn visit_await_statement(
        &mut self,
        expr: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let value = self.evaluate(expr, env)?;
        Ok(ControlFlow::Normal(value))
    }

    fn visit_field_access(
        &mut self,
        object: &ASTNode,
        field: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        if let ASTNode::Identifier { name: obj_name, .. } = &*object {
            if obj_name == "this" {
                if let Some(obj) = &env.lock().unwrap().object {
                    let obj_guard = obj.lock().unwrap();
                    if let Value::Object { fields, .. } = &*obj_guard {
                        if let ASTNode::Identifier { name: field_name, .. } = &*field {
                            if let Some(field_val) = fields.get(field_name) {
                                return Ok(ControlFlow::Normal(field_val.lock().unwrap().clone()));
                            } else {
                                return Err(
                                    format!(
                                        "Field '{}' not found at line {}, column {}",
                                        field_name,
                                        line,
                                        column
                                    )
                                );
                            }
                        }
                    }
                    return Err(
                        format!(
                            "Field access on non-object 'this' at line {}, column {}",
                            line,
                            column
                        )
                    );
                } else {
                    return Err(
                        format!("No 'this' object in context at line {}, column {}", line, column)
                    );
                }
            }
        }

        let obj_val = self.evaluate(object, env)?;
        match &obj_val {
            Value::Object { fields, class, module, .. } => {
                if let ASTNode::Identifier { name, .. } = &*field {
                    if let Some(field_val) = fields.get(name) {
                        return Ok(ControlFlow::Normal(field_val.lock().unwrap().clone()));
                    }
                    let class_val = env
                        .lock()
                        .unwrap()
                        .get(class)
                        .map_err(|_| {
                            format!(
                                "Class '{}' not found at line {}, column {}",
                                class,
                                line,
                                column
                            )
                        })?;
                    if let Value::Class { env: class_env, .. } = &*class_val.lock().unwrap() {
                        if let Ok(method_val) = class_env.lock().unwrap().get(name) {
                            if
                                let Value::Function {
                                    name: fn_name,
                                    params,
                                    body,
                                    closure,
                                    ..
                                } = method_val.lock().unwrap().clone()
                            {
                                let bound_method = Value::Function {
                                    name: fn_name,
                                    params,
                                    body,
                                    closure,
                                    object: Some(Arc::new(Mutex::new(obj_val.clone()))),
                                };
                                return Ok(ControlFlow::Normal(bound_method));
                            }
                        }
                    }
                    if let Some(module_name) = module {
                        let modules_guard = self.modules.lock().unwrap();
                        if let Some(mod_env) = modules_guard.get(module_name) {
                            let value = mod_env
                                .lock()
                                .unwrap()
                                .get(name)
                                .map_err(|_| {
                                    format!(
                                        "Field '{}' not found in module '{}' at line {}, column {}",
                                        name,
                                        module_name,
                                        line,
                                        column
                                    )
                                })?;
                            return Ok(ControlFlow::Normal(value.lock().unwrap().clone()));
                        }
                    }
                    Err(format!("Field '{}' not found at line {}, column {}", name, line, column))
                } else {
                    Err(format!("Invalid field access at line {}, column {}", line, column))
                }
            }
            Value::Module { env: mod_env, .. } => {
                if let ASTNode::Identifier { name, .. } = &*field {
                    let value = mod_env
                        .lock()
                        .unwrap()
                        .get(name)
                        .map_err(|_| {
                            format!(
                                "'{}' not found in module at line {}, column {}",
                                name,
                                line,
                                column
                            )
                        })?;
                    Ok(ControlFlow::Normal(value.lock().unwrap().clone()))
                } else {
                    Err(
                        format!(
                            "Invalid field access on module at line {}, column {}",
                            line,
                            column
                        )
                    )
                }
            }
            _ =>
                Err(
                    format!(
                        "Field access on non-object/non-module at line {}, column {}",
                        line,
                        column
                    )
                ),
        }
    }

    fn visit_parent_method_access(
        &mut self,
        method: &str,
        args: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let this = env
            .lock()
            .unwrap()
            .get("this")
            .map_err(|_| {
                format!("'this' not found in current scope at line {}, column {}", line, column)
            })?;
        if let Value::Object { parent, .. } = this.lock().unwrap().clone() {
            if let Some(parent_obj) = parent {
                if let Value::Object { fields, .. } = parent_obj.lock().unwrap().clone() {
                    if let Some(method_val) = fields.get(method) {
                        if
                            let Value::Function { params, body, closure, .. } = method_val
                                .lock()
                                .unwrap()
                                .clone()
                        {
                            // Count required parameters (those without defaults)
                            let required_params = params
                                .iter()
                                .filter(|p| p.1.is_none())
                                .count();
                            if args.len() < required_params || args.len() > params.len() {
                                return Err(
                                    format!(
                                        "Parent method '{}' expects at least {} and at most {} arguments, got {} at line {}, column {}",
                                        method,
                                        required_params,
                                        params.len(),
                                        args.len(),
                                        line,
                                        column
                                    )
                                );
                            }
                            let mut new_env = Arc::new(Mutex::new(Environment::new(Some(closure))));
                            new_env
                                .lock()
                                .unwrap()
                                .define("this".to_string(), parent_obj.lock().unwrap().clone())?;
                            let arg_values = args
                                .iter()
                                .map(|arg| self.evaluate(arg, env))
                                .collect::<Result<Vec<_>, _>>()?;
                            for (i, (param_name, default)) in params.iter().enumerate() {
                                let arg_val = if i < arg_values.len() {
                                    arg_values[i].clone()
                                } else {
                                    default.clone().unwrap() // Safe: i >= required_params
                                };
                                new_env.lock().unwrap().define(param_name.clone(), arg_val)?;
                            }
                            let mut local_env = new_env;
                            let result = self.visit_block(&body, &mut local_env)?;
                            match result {
                                ControlFlow::Return(value) => Ok(ControlFlow::Normal(value)),
                                ControlFlow::Normal(_) => Ok(ControlFlow::Normal(Value::Null)),
                                other => Ok(other),
                            }
                        } else {
                            Err(
                                format!(
                                    "OOP Error: '{}' is not a method in parent at line {}, column {}",
                                    method,
                                    line,
                                    column
                                )
                            )
                        }
                    } else {
                        Err(
                            format!(
                                "OOP Error: Parent method '{}' not found at line {}, column {}",
                                method,
                                line,
                                column
                            )
                        )
                    }
                } else {
                    Err(
                        format!(
                            "OOP Error: Parent is not an object at line {}, column {}",
                            line,
                            column
                        )
                    )
                }
            } else {
                Err(
                    format!(
                        "OOP Error: No parent object available at line {}, column {}",
                        line,
                        column
                    )
                )
            }
        } else {
            Err(format!("OOP Error: Not in object context at line {}, column {}", line, column))
        }
    }

    fn visit_parent_access(
        &mut self,
        field: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let this = env
            .lock()
            .unwrap()
            .get("this")
            .map_err(|_| {
                format!("'this' not found in current scope at line {}, column {}", line, column)
            })?;
        if let Value::Object { parent, .. } = this.lock().unwrap().clone() {
            if let Some(parent_obj) = parent {
                if let Value::Object { fields, .. } = parent_obj.lock().unwrap().clone() {
                    match field {
                        ASTNode::Identifier { name, .. } => {
                            if let Some(field_val) = fields.get(name) {
                                Ok(ControlFlow::Normal(field_val.lock().unwrap().clone()))
                            } else {
                                Err(
                                    format!(
                                        "Parent field '{}' not found at line {}, column {}",
                                        name,
                                        line,
                                        column
                                    )
                                )
                            }
                        }
                        _ =>
                            Err(
                                format!(
                                    "Invalid parent field access at line {}, column {}",
                                    line,
                                    column
                                )
                            ),
                    }
                } else {
                    Err(format!("Parent is not an object at line {}, column {}", line, column))
                }
            } else {
                Err(format!("No parent object available at line {}, column {}", line, column))
            }
        } else {
            Err(format!("Not in object context at line {}, column {}", line, column))
        }
    }

    fn visit_callback(
        &mut self,
        name: &str,
        params: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let param_names = params
            .iter()
            .filter_map(|p| {
                if let ASTNode::Identifier { name, .. } = &**p { Some(name.clone()) } else { None }
            })
            .collect::<Vec<_>>();
        let cb = Value::Callback(name.to_string());
        env.lock().unwrap().define(name.to_string(), cb)?;
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_ternary(
        &mut self,
        condition: &ASTNode,
        then_expr: &ASTNode,
        else_expr: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let cond_val = self.evaluate_to_bool(condition, env)?;
        let result = if cond_val {
            self.evaluate(then_expr, env)?
        } else {
            self.evaluate(else_expr, env)?
        };
        Ok(ControlFlow::Normal(result))
    }

    fn visit_binary_operation(
        &mut self,
        left: &ASTNode,
        operator: &TokenType,
        right: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let left_val = self.evaluate(left, env)?;
        let right_val = self.evaluate(right, env)?;

        match (left_val, operator, right_val) {
            // Existing arithmetic and comparison operators
            (Value::Number(l), TokenType::Plus, Value::Number(r)) =>
                Ok(ControlFlow::Normal(Value::Number(l + r))),
            (Value::String(l), TokenType::Plus, Value::String(r)) =>
                Ok(ControlFlow::Normal(Value::String(l + &r))),
            (Value::String(l), TokenType::Plus, r) =>
                Ok(ControlFlow::Normal(Value::String(l + &r.to_string()))),
            (l, TokenType::Plus, Value::String(r)) =>
                Ok(ControlFlow::Normal(Value::String(l.to_string() + &r))),
            (Value::Number(l), TokenType::Minus, Value::Number(r)) =>
                Ok(ControlFlow::Normal(Value::Number(l - r))),
            (Value::Number(l), TokenType::Multiply, Value::Number(r)) =>
                Ok(ControlFlow::Normal(Value::Number(l * r))),
            (Value::Number(l), TokenType::Divide, Value::Number(r)) if r != 0.0 =>
                Ok(ControlFlow::Normal(Value::Number(l / r))),
            (Value::Number(l), TokenType::Modulus, Value::Number(r)) if r != 0.0 =>
                Ok(ControlFlow::Normal(Value::Number(l % r))),
            (Value::Number(l), TokenType::Power, Value::Number(r)) =>
                Ok(ControlFlow::Normal(Value::Number(l.powf(r)))),
            (l, TokenType::IsEqual, r) => Ok(ControlFlow::Normal(Value::Bool(l == r))),
            (Value::Number(l), TokenType::LessThan, Value::Number(r)) =>
                Ok(ControlFlow::Normal(Value::Bool(l < r))),
            (Value::Number(l), TokenType::LessThanEqual, Value::Number(r)) =>
                Ok(ControlFlow::Normal(Value::Bool(l <= r))),
            (l, TokenType::NotEqual, r) => Ok(ControlFlow::Normal(Value::Bool(l != r))),
            (Value::Number(l), TokenType::GreaterThan, Value::Number(r)) =>
                Ok(ControlFlow::Normal(Value::Bool(l > r))),
            (Value::Number(l), TokenType::GreaterThanEqual, Value::Number(r)) =>
                Ok(ControlFlow::Normal(Value::Bool(l >= r))),
            (Value::Bool(l), TokenType::And, Value::Bool(r)) =>
                Ok(ControlFlow::Normal(Value::Bool(l && r))),
            (Value::Bool(l), TokenType::Or, Value::Bool(r)) =>
                Ok(ControlFlow::Normal(Value::Bool(l || r))),

            // New: `is` operator
            (l, TokenType::Is, r) => {
                match (&l, &r) {
                    // Identity-like comparison for Null
                    (Value::Null, Value::Null) => Ok(ControlFlow::Normal(Value::Bool(true))),
                    (Value::Null, _) | (_, Value::Null) =>
                        Ok(ControlFlow::Normal(Value::Bool(false))),
                    // Structural equality for basic types
                    (Value::Number(l_num), Value::Number(r_num)) =>
                        Ok(ControlFlow::Normal(Value::Bool(l_num == r_num))),
                    (Value::String(l_str), Value::String(r_str)) =>
                        Ok(ControlFlow::Normal(Value::Bool(l_str == r_str))),
                    (Value::Bool(l_bool), Value::Bool(r_bool)) =>
                        Ok(ControlFlow::Normal(Value::Bool(l_bool == r_bool))),
                    // For complex types, assume `is` requires exact type match and equality
                    (Value::Array(l_arr), Value::Array(r_arr)) => {
                        if l_arr.len() != r_arr.len() {
                            Ok(ControlFlow::Normal(Value::Bool(false)))
                        } else {
                            let is_equal = l_arr
                                .iter()
                                .zip(r_arr.iter())
                                .all(|(l_elem, r_elem)| {
                                    let l_val = l_elem.lock().unwrap();
                                    let r_val = r_elem.lock().unwrap();
                                    *l_val == *r_val // Relies on PartialEq for Value
                                });
                            Ok(ControlFlow::Normal(Value::Bool(is_equal)))
                        }
                    }
                    (Value::Dictionary(l_dict), Value::Dictionary(r_dict)) => {
                        if l_dict.len() != r_dict.len() {
                            Ok(ControlFlow::Normal(Value::Bool(false)))
                        } else {
                            let is_equal = l_dict.iter().all(|(k, l_val)| {
                                if let Some(r_val) = r_dict.get(k) {
                                    let l_val_guard = l_val.lock().unwrap();
                                    let r_val_guard = r_val.lock().unwrap();
                                    *l_val_guard == *r_val_guard
                                } else {
                                    false
                                }
                            });
                            Ok(ControlFlow::Normal(Value::Bool(is_equal)))
                        }
                    }
                    // Different types are not identical
                    _ => Ok(ControlFlow::Normal(Value::Bool(false))),
                }
            }
            // New: `is not` operator
            (l, TokenType::IsNot, r) => {
                match (&l, &r) {
                    (Value::Null, Value::Null) => Ok(ControlFlow::Normal(Value::Bool(false))),
                    (Value::Null, _) | (_, Value::Null) =>
                        Ok(ControlFlow::Normal(Value::Bool(true))),
                    (Value::Array(l_arr), Value::Array(r_arr)) => {
                        if l_arr.len() != r_arr.len() {
                            Ok(ControlFlow::Normal(Value::Bool(true)))
                        } else {
                            let is_equal = l_arr
                                .iter()
                                .zip(r_arr.iter())
                                .all(|(l_elem, r_elem)| {
                                    let l_val = l_elem.lock().unwrap();
                                    let r_val = r_elem.lock().unwrap();
                                    *l_val == *r_val
                                });
                            Ok(ControlFlow::Normal(Value::Bool(!is_equal)))
                        }
                    }
                    (Value::Dictionary(l_dict), Value::Dictionary(r_dict)) => {
                        if l_dict.len() != r_dict.len() {
                            Ok(ControlFlow::Normal(Value::Bool(true)))
                        } else {
                            let is_equal = l_dict.iter().all(|(k, l_val)| {
                                r_dict.get(k).map_or(false, |r_val| {
                                    let l_val_guard = l_val.lock().unwrap();
                                    let r_val_guard = r_val.lock().unwrap();
                                    *l_val_guard == *r_val_guard
                                })
                            });
                            Ok(ControlFlow::Normal(Value::Bool(!is_equal)))
                        }
                    }
                    _ => Ok(ControlFlow::Normal(Value::Bool(l != r))),
                }
            }
            // New: `in` operator
            (l, TokenType::In, Value::Array(r_arr)) => {
                let is_present = r_arr.iter().any(|elem| {
                    let elem_val = elem.lock().unwrap();
                    *elem_val == l // Relies on PartialEq for Value
                });
                Ok(ControlFlow::Normal(Value::Bool(is_present)))
            }
            (l, TokenType::In, Value::Dictionary(r_dict)) => {
                // Check if `l` is a key in the dictionary
                let l_str = match &l {
                    Value::String(s) => s,
                    _ => {
                        return Err(
                            format!(
                                "Type Error: Dictionary keys must be strings for 'in' at line {}, column {}",
                                line,
                                column
                            )
                        );
                    }
                };
                Ok(ControlFlow::Normal(Value::Bool(r_dict.contains_key(l_str))))
            }
            (_, TokenType::In, r) =>
                Err(
                    format!(
                        "Type Error: 'in' requires an array or dictionary on the right at line {}, column {}, got {}",
                        line,
                        column,
                        r.to_string()
                    )
                ),

            // New: `is in` operator
            (l, TokenType::IsIn, Value::Array(r_arr)) => {
                let is_present = r_arr.iter().any(|elem| {
                    let elem_val = elem.lock().unwrap();
                    match (&l, &*elem_val) {
                        (Value::Null, Value::Null) => true,
                        (Value::Null, _) | (_, Value::Null) => false,
                        (Value::Number(l_num), Value::Number(r_num)) => l_num == r_num,
                        (Value::String(l_str), Value::String(r_str)) => l_str == r_str,
                        (Value::Bool(l_bool), Value::Bool(r_bool)) => l_bool == r_bool,
                        _ => false, // Different types are not identical
                    }
                });
                Ok(ControlFlow::Normal(Value::Bool(is_present)))
            }
            (l, TokenType::IsIn, Value::Dictionary(r_dict)) => {
                let is_present = r_dict.values().any(|val| {
                    let val_guard = val.lock().unwrap();
                    match (&l, &*val_guard) {
                        (Value::Null, Value::Null) => true,
                        (Value::Null, _) | (_, Value::Null) => false,
                        (Value::Number(l_num), Value::Number(r_num)) => l_num == r_num,
                        (Value::String(l_str), Value::String(r_str)) => l_str == r_str,
                        (Value::Bool(l_bool), Value::Bool(r_bool)) => l_bool == r_bool,
                        _ => false, // Different types are not identical
                    }
                });
                Ok(ControlFlow::Normal(Value::Bool(is_present)))
            }
            (_, TokenType::IsIn, r) =>
                Err(
                    format!(
                        "Type Error: 'is in' requires an array or dictionary on the right at line {}, column {}, got {}",
                        line,
                        column,
                        r.to_string()
                    )
                ),
            // Catch-all for invalid operations
            _ =>
                Err(
                    format!(
                        "Operation Error: Invalid binary operation at line {}, column {}",
                        line,
                        column
                    )
                ),
        }
    }

    fn visit_unary_operation(
        &mut self,
        operator: &TokenType,
        expr: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let val = self.evaluate(expr, env)?;
        match (operator, val) {
            (TokenType::Not, Value::Bool(b)) => Ok(ControlFlow::Normal(Value::Bool(!b))),
            (TokenType::Minus, Value::Number(n)) => Ok(ControlFlow::Normal(Value::Number(-n))),
            _ => Err(format!("Invalid unary operation at line {}, column {}", line, column)),
        }
    }

    fn visit_array_element(
        &mut self,
        elements: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let arr = elements
            .iter()
            .map(|e| self.evaluate(e, env).map(|v| Arc::new(Mutex::new(v))))
            .collect::<Result<Vec<_>, _>>()?;
        Ok(ControlFlow::Normal(Value::Array(arr)))
    }

    fn visit_array_access(
        &mut self,
        name: &str,
        indices: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let array = env
            .lock()
            .unwrap()
            .get(name)
            .map_err(|_| {
                format!("Array '{}' not found at line {}, column {}", name, line, column)
            })?;
        let mut current = array;
        for index in indices {
            let idx = self.evaluate_to_number(index, env)? as usize;
            let next = {
                let current_guard = current.lock().unwrap();
                match &*current_guard {
                    Value::Array(arr) => {
                        if idx < arr.len() {
                            arr[idx].clone()
                        } else {
                            return Err(
                                format!(
                                    "Array index out of bounds at line {}, column {}",
                                    line,
                                    column
                                )
                            );
                        }
                    }
                    _ => {
                        return Err(format!("Not an array at line {}, column {}", line, column));
                    }
                }
            };
            current = next;
        }
        Ok(ControlFlow::Normal(current.lock().unwrap().clone()))
    }

    fn visit_dictionary(
        &mut self,
        pairs: &[(Box<ASTNode>, Box<ASTNode>)],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let mut dict = HashMap::new();
        for (key, value) in pairs {
            let key_str = match self.evaluate(key, env)? {
                Value::String(s) => s,
                _ => {
                    return Err(
                        format!(
                            "Dictionary Error: Dictionary key must be a string at line {}, column {}",
                            line,
                            column
                        )
                    );
                }
            };
            let val = self.evaluate(value, env)?;
            dict.insert(key_str, Arc::new(Mutex::new(val)));
        }
        Ok(ControlFlow::Normal(Value::Dictionary(dict)))
    }

    fn visit_dictionary_access(
        &mut self,
        name: &str,
        keys: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let dict = env
            .lock()
            .unwrap()
            .get(name)
            .map_err(|_| {
                format!(
                    "Dictionary Error: Dictionary '{}' not found at line {}, column {}",
                    name,
                    line,
                    column
                )
            })?;
        let mut current = dict;
        for key in keys {
            let key_str = match self.evaluate(key, env)? {
                Value::String(s) => s,
                _ => {
                    return Err(
                        format!(
                            "Dictionary Error: Dictionary key must be a string at line {}, column {}",
                            line,
                            column
                        )
                    );
                }
            };
            let next = {
                let current_guard = current.lock().unwrap();
                match &*current_guard {
                    Value::Dictionary(d) => {
                        if let Some(val) = d.get(&key_str) {
                            val.clone()
                        } else {
                            return Err(
                                format!(
                                    "Dictionary Error: Key '{}' not found in dictionary at line {}, column {}",
                                    key_str,
                                    line,
                                    column
                                )
                            );
                        }
                    }
                    _ => {
                        return Err(
                            format!(
                                "Dictionary Error: Not a dictionary at line {}, column {}",
                                line,
                                column
                            )
                        );
                    }
                }
            };
            current = next;
        }
        Ok(ControlFlow::Normal(current.lock().unwrap().clone()))
    }

    fn visit_class_instantiation(
        &mut self,
        class_expr: &ASTNode,
        args: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let class_val = self.evaluate(class_expr, env)?;
        match class_val {
            Value::Class { ast, env: class_env } => {
                if let ASTNode::ClassDecl { name, inherit, body, .. } = &*ast {
                    let mut fields = HashMap::new();
                    let parent = if let Some(parent_name) = inherit {
                        let parent_obj = self.visit_class_instantiation(
                            &(ASTNode::Identifier { name: parent_name.clone(), line, column }),
                            &[],
                            line,
                            column,
                            env
                        )?;
                        if
                            let ControlFlow::Normal(
                                Value::Object { fields: parent_fields, class_ast: parent_ast, .. },
                            ) = parent_obj
                        {
                            Some(
                                Arc::new(
                                    Mutex::new(Value::Object {
                                        class: parent_name.clone(),
                                        fields: parent_fields,
                                        class_ast: parent_ast,
                                        parent: None,
                                        module: None,
                                    })
                                )
                            )
                        } else {
                            return Err(
                                format!(
                                    "Failed to instantiate parent class '{}' at line {}, column {}",
                                    parent_name,
                                    line,
                                    column
                                )
                            );
                        }
                    } else {
                        None
                    };

                    for member in body {
                        match member {
                            ASTNode::FieldDecl { decl, .. } => {
                                match &**decl {
                                    ASTNode::Declaration { names, .. } => {
                                        for name in names {
                                            if let ASTNode::Identifier { name, .. } = &**name {
                                                fields.insert(
                                                    name.clone(),
                                                    Arc::new(Mutex::new(Value::Null))
                                                );
                                            }
                                        }
                                    }
                                    ASTNode::AssignStatement { target, value, .. } => {
                                        if let ASTNode::Identifier { name, .. } = &**target {
                                            let val = self.evaluate(value, env)?;
                                            fields.insert(name.clone(), Arc::new(Mutex::new(val)));
                                        }
                                    }

                                    ASTNode::SetStatement { target, value, .. } => {
                                        if let ASTNode::Identifier { name, .. } = &**target {
                                            let val = self.evaluate(value, env)?;
                                            fields.insert(name.clone(), Arc::new(Mutex::new(val)));
                                        }
                                    }
                                    _ => {}
                                }
                            }
                            _ => {}
                        }
                    }

                    for member in body {
                        if let ASTNode::ConstructorDecl { params, body, .. } = member {
                            let param_names = params
                                .iter()
                                .filter_map(|p| {
                                    if let ASTNode::Identifier { name, .. } = &**p {
                                        Some(name.clone())
                                    } else {
                                        None
                                    }
                                })
                                .collect::<Vec<_>>();
                            if param_names.len() == args.len() {
                                let obj = Arc::new(
                                    Mutex::new(Value::Object {
                                        class: name.clone(),
                                        fields: fields.clone(),
                                        class_ast: ast.clone(),
                                        parent: parent.clone(),
                                        module: None,
                                    })
                                );
                                let mut new_env = Arc::new(
                                    Mutex::new(Environment::new(Some(env.clone())))
                                );
                                {
                                    let mut env_guard = new_env.lock().unwrap();
                                    env_guard.object = Some(obj.clone());
                                    env_guard.define(
                                        "this".to_string(),
                                        obj.lock().unwrap().clone()
                                    )?;
                                }
                                for (param, arg) in param_names.iter().zip(args) {
                                    let arg_val = self.evaluate(arg, env)?;
                                    new_env.lock().unwrap().define(param.clone(), arg_val)?;
                                }
                                let mut local_env = new_env;
                                self.visit_block(body, &mut local_env)?;
                                if
                                    let Value::Object { fields: updated_fields, .. } = &*obj
                                        .lock()
                                        .unwrap()
                                {
                                    fields = updated_fields.clone();
                                }
                            }
                        }
                    }
                    Ok(
                        ControlFlow::Normal(Value::Object {
                            class: name.clone(),
                            fields,
                            class_ast: ast.clone(),
                            parent,
                            module: None,
                        })
                    )
                } else {
                    Err(format!("Invalid class definition at line {}, column {}", line, column))
                }
            }
            Value::Module { name, env: mod_env } => {
                if !args.is_empty() {
                    return Err(
                        format!(
                            "Module '{}' does not accept arguments at line {}, column {}",
                            name,
                            line,
                            column
                        )
                    );
                }
                Ok(
                    ControlFlow::Normal(Value::Object {
                        class: name.clone(),
                        fields: HashMap::new(),
                        class_ast: Box::new(ASTNode::Null { line, column }),
                        parent: None,
                        module: Some(name.clone()),
                    })
                )
            }
            _ =>
                Err(
                    format!(
                        "'{}' is not instantiable at line {}, column {}",
                        class_val.to_string(),
                        line,
                        column
                    )
                ),
        }
    }

    fn visit_byte_array(
        &mut self,
        args: &[Option<Box<ASTNode>>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let mut bytes = Vec::new();
        for arg in args {
            if let Some(expr) = arg {
                match self.evaluate(expr, env)? {
                    Value::Number(n) if n >= 0.0 && n <= 255.0 && n.fract() == 0.0 =>
                        bytes.push(n as u8),
                    _ => {
                        return Err(
                            format!(
                                "ByteArray expects integers between 0 and 255 at line {}, column {}",
                                line,
                                column
                            )
                        );
                    }
                }
            }
        }
        Ok(ControlFlow::Normal(Value::ByteArray(bytes)))
    }

    fn visit_hex_literal(
        &mut self,
        value: &str,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let trimmed = value.trim_start_matches("0x");
        match u64::from_str_radix(trimmed, 16) {
            Ok(num) => Ok(ControlFlow::Normal(Value::Number(num as f64))),
            Err(_) =>
                Err(format!("Invalid hex literal '{}' at line {}, column {}", value, line, column)),
        }
    }

    fn visit_bytes_literal(
        &mut self,
        value: &str,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let trimmed = value.trim_start_matches("0b");
        match u64::from_str_radix(trimmed, 2) {
            Ok(num) => Ok(ControlFlow::Normal(Value::Number(num as f64))),
            Err(_) =>
                Err(
                    format!("Invalid bytes literal '{}' at line {}, column {}", value, line, column)
                ),
        }
    }

    fn visit_identifier(
        &mut self,
        name: &str,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let value = env
            .lock()
            .unwrap()
            .get(name)
            .map_err(|_| {
                format!(
                    "Name Error: Variable '{}' not found at line {}, column {}",
                    name,
                    line,
                    column
                )
            })?;
        Ok(ControlFlow::Normal(value.lock().unwrap().clone()))
    }

    fn visit_field_decl(
        &mut self,
        _modifier: &Option<TokenType>,
        decl: &ASTNode,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        match decl {
            ASTNode::AssignStatement { target, value, .. } => {
                if let ASTNode::Identifier { name, .. } = &**target {
                    let val = self.evaluate(value, env)?;
                    env.lock().unwrap().define(name.clone(), val)?;
                } else {
                    return Err(
                        format!(
                            "Invalid field declaration target at line {}, column {}",
                            line,
                            column
                        )
                    );
                }
            }
            _ => {
                return Err(
                    format!("Invalid field declaration at line {}, column {}", line, column)
                );
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_method_decl(
        &mut self,
        _modifier: &Option<TokenType>,
        name: &str,
        params: &[Box<ASTNode>],
        body: &[ASTNode],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let mut param_list = Vec::new();
        let mut has_default = false;

        // Process each parameter
        for param in params {
            match &**param {
                ASTNode::Identifier { name, .. } => {
                    if has_default {
                        return Err(
                            format!(
                                "Parameters with defaults must come after those without at line {}, column {}",
                                line,
                                column
                            )
                        );
                    }
                    param_list.push((name.clone(), None));
                }
                ASTNode::AssignStatement { target, value, .. } => {
                    if let ASTNode::Identifier { name, .. } = &**target {
                        let default_val = self.evaluate(value, env)?;
                        param_list.push((name.clone(), Some(default_val)));
                        has_default = true;
                    } else {
                        return Err(
                            format!("Invalid parameter default at line {}, column {}", line, column)
                        );
                    }
                }
                _ => {
                    return Err(
                        format!(
                            "Invalid parameter in method declaration at line {}, column {}",
                            line,
                            column
                        )
                    );
                }
            }
        }

        // Define the method
        let method = Value::Function {
            name: name.to_string(),
            params: param_list,
            body: body.to_vec(),
            closure: env.clone(),
            object: None,
        };
        env.lock().unwrap().define(name.to_string(), method)?;
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_constructor_decl(
        &mut self,
        _modifier: &Option<TokenType>,
        params: &[Box<ASTNode>],
        body: &[ASTNode],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let mut param_list = Vec::new();
        let mut has_default = false;

        // Process each parameter
        for param in params {
            match &**param {
                ASTNode::Identifier { name, .. } => {
                    if has_default {
                        return Err(
                            format!(
                                "Parameters with defaults must come after those without at line {}, column {}",
                                line,
                                column
                            )
                        );
                    }
                    param_list.push((name.clone(), None));
                }
                ASTNode::AssignStatement { target, value, .. } => {
                    if let ASTNode::Identifier { name, .. } = &**target {
                        let default_val = self.evaluate(value, env)?;
                        param_list.push((name.clone(), Some(default_val)));
                        has_default = true;
                    } else {
                        return Err(
                            format!("Invalid parameter default at line {}, column {}", line, column)
                        );
                    }
                }
                _ => {
                    return Err(
                        format!(
                            "Invalid parameter in constructor declaration at line {}, column {}",
                            line,
                            column
                        )
                    );
                }
            }
        }

        // Define the constructor
        let constructor = Value::Function {
            name: "init".to_string(),
            params: param_list,
            body: body.to_vec(),
            closure: env.clone(),
            object: None,
        };
        env.lock().unwrap().define("init".to_string(), constructor)?;
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_parent_constructor_call(
        &mut self,
        args: &[Box<ASTNode>],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        let this = env
            .lock()
            .unwrap()
            .get("this")
            .map_err(|_| {
                format!("'this' not found in current scope at line {}, column {}", line, column)
            })?;
        if let Value::Object { parent, .. } = this.lock().unwrap().clone() {
            if let Some(parent_obj) = parent {
                let parent_class = match &*parent_obj.lock().unwrap() {
                    Value::Object { class, .. } => class.clone(),
                    _ => {
                        return Err(
                            format!("Parent is not an object at line {}, column {}", line, column)
                        );
                    }
                };
                // Scope the lock and clone the class node
                let class_node = {
                    let classes_guard = self.classes.lock().unwrap();
                    classes_guard
                        .get(&parent_class)
                        .cloned() // Clone the ASTNode to use it outside this scope
                        .ok_or_else(||
                            format!(
                                "Class '{}' not found at line {}, column {}",
                                parent_class,
                                line,
                                column
                            )
                        )?
                };
                if let ASTNode::ClassDecl { body, .. } = class_node {
                    let constructor_info = body
                        .iter()
                        .find_map(|member| {
                            if let ASTNode::ConstructorDecl { params, body, .. } = member {
                                Some((params.clone(), body.clone()))
                            } else {
                                None
                            }
                        })
                        .ok_or_else(||
                            format!(
                                "Constructor not found in parent class '{}' at line {}, column {}",
                                parent_class,
                                line,
                                column
                            )
                        )?;
                    let (params, constructor_body) = constructor_info;
                    let param_names = params
                        .iter()
                        .filter_map(|p| {
                            if let ASTNode::Identifier { name, .. } = &**p {
                                Some(name.clone())
                            } else {
                                None
                            }
                        })
                        .collect::<Vec<_>>();
                    if param_names.len() != args.len() {
                        return Err(
                            format!(
                                "Parent constructor expects {} arguments, got {} at line {}, column {}",
                                param_names.len(),
                                args.len(),
                                line,
                                column
                            )
                        );
                    }
                    let mut new_env = Arc::new(Mutex::new(Environment::new(Some(env.clone()))));
                    new_env
                        .lock()
                        .unwrap()
                        .define("this".to_string(), parent_obj.lock().unwrap().clone())?;
                    for (param, arg) in param_names.iter().zip(args) {
                        let arg_val = self.evaluate(arg, env)?; // No conflict now
                        new_env.lock().unwrap().define(param.clone(), arg_val)?;
                    }
                    let mut local_env = new_env;
                    let result = self.visit_block(&constructor_body, &mut local_env)?; // No conflict now
                    match result {
                        ControlFlow::Normal(_) => Ok(ControlFlow::Normal(Value::Null)),
                        other => Ok(other),
                    }
                } else {
                    Err(
                        format!(
                            "Invalid class definition for '{}' at line {}, column {}",
                            parent_class,
                            line,
                            column
                        )
                    )
                }
            } else {
                Err(format!("No parent object available at line {}, column {}", line, column))
            }
        } else {
            Err(format!("Not in object context at line {}, column {}", line, column))
        }
    }

    fn evaluate(
        &mut self,
        node: &ASTNode,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<Value, String> {
        match self.visit(node, env)? {
            ControlFlow::Normal(value) => Ok(value),
            ControlFlow::Return(value) => Ok(value),
            ControlFlow::Throw(e) => Err(format!("Thrown: {:?}", e)),
            _ => Err("Unexpected control flow in expression".to_string()),
        }
    }

    fn evaluate_to_number(
        &mut self,
        node: &ASTNode,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<f64, String> {
        match self.evaluate(node, env)? {
            Value::Number(n) => Ok(n),
            _ => Err("Value Error: Expected a number".to_string()),
        }
    }

    fn evaluate_to_bool(
        &mut self,
        node: &ASTNode,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<bool, String> {
        Ok(self.evaluate(node, env)?.to_bool())
    }

    fn create_array(&self, dimensions: &[usize]) -> Result<Value, String> {
        if dimensions.is_empty() {
            Ok(Value::Null)
        } else {
            let size = dimensions[0];
            let sub_array = self.create_array(&dimensions[1..])?;
            Ok(Value::Array((0..size).map(|_| Arc::new(Mutex::new(sub_array.clone()))).collect()))
        }
    }

    fn assign_array_element(
        &mut self,
        array: &Arc<Mutex<Value>>,
        indices: &[Box<ASTNode>],
        value: Value,
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<(), String> {
        let mut current = array.clone();
        for (i, idx) in indices.iter().enumerate() {
            let index = self.evaluate_to_number(idx, env)? as usize;
            let next = {
                let mut current_guard = current.lock().unwrap();
                match &mut *current_guard {
                    Value::Array(arr) => {
                        if index >= arr.len() {
                            return Err(
                                format!(
                                    "List Error: List index out of bounds at line {}, column {}",
                                    line,
                                    column
                                )
                            );
                        }
                        if i == indices.len() - 1 {
                            *arr[index].lock().unwrap() = value;
                            return Ok(());
                        } else {
                            arr[index].clone()
                        }
                    }
                    _ => {
                        return Err(
                            format!("Type Error: Not a List at line {}, column {}", line, column)
                        );
                    }
                }
            };
            current = next;
        }
        Err(format!("Invalid list access at line {}, column {}", line, column))
    }

    fn load_module(
        &mut self,
        module_name: &str,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<(), String> {
        // Step 1: Check if the module is already loaded
        {
            let modules_guard = self.modules.lock().unwrap();
            if modules_guard.contains_key(module_name) {
                return Ok(());
            }
        } // Lock is released here as `modules_guard` goes out of scope

        // Step 2: Load the module without holding the lock
        let module_path = Self::resolve_module_path(module_name)?;
        let source = std::fs
            ::read_to_string(&module_path)
            .map_err(|e| format!("Failed to read module '{}': {}", module_name, e))?;
        let mut lexer = Lexer::new(&source);
        let mut parser = Parser::new(&source)?;
        let ast = parser.parse()?;
        let module_env = Arc::new(Mutex::new(Environment::new(None)));
        let mut local_env = module_env.clone();
        self.visit(&ast, &mut local_env)?; // Mutable borrow of `self` is now allowed

        // Step 3: Lock again to insert the module environment
        let mut modules_guard = self.modules.lock().unwrap();
        if !modules_guard.contains_key(module_name) {
            modules_guard.insert(module_name.to_string(), module_env);
        }
        Ok(())
    }

    fn visit_import_statement(
        &mut self,
        modules: &[String],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        for module_name in modules {
            self.load_module(module_name, env)?;
            let modules_guard = self.modules.lock().unwrap();
            if let Some(mod_env) = modules_guard.get(module_name) {
                let module_value = Value::Module {
                    name: module_name.clone(),
                    env: mod_env.clone(),
                };
                env.lock().unwrap().define(module_name.clone(), module_value)?;
                for (name, value) in mod_env.lock().unwrap().values.read().unwrap().iter() {
                    if let Value::Class { .. } = &*value.lock().unwrap() {
                        env.lock().unwrap().define(name.clone(), value.lock().unwrap().clone())?;
                    }
                }
            } else {
                return Err(
                    format!(
                        "Module '{}' not found at line {}, column {}",
                        module_name,
                        line,
                        column
                    )
                );
            }
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn visit_from_import_statement(
        &mut self,
        module: &str,
        imported: &[String],
        line: usize,
        column: usize,
        env: &mut Arc<Mutex<Environment>>
    ) -> Result<ControlFlow, String> {
        self.load_module(module, env)?;
        let modules_guard = self.modules.lock().unwrap();
        if let Some(mod_env) = modules_guard.get(module) {
            for name in imported {
                let value = mod_env
                    .lock()
                    .unwrap()
                    .get(name)
                    .map_err(|_| {
                        format!(
                            "'{}' not found in module '{}' at line {}, column {}",
                            name,
                            module,
                            line,
                            column
                        )
                    })?;
                env.lock().unwrap().define(name.clone(), value.lock().unwrap().clone())?;
            }
        } else {
            return Err(
                format!("Module '{}' not found at line {}, column {}", module, line, column)
            );
        }
        Ok(ControlFlow::Normal(Value::Null))
    }

    fn resolve_module_path(module_name: &str) -> Result<PathBuf, String> {
        // Split the module name into parts (e.g., "a.b.c" -> ["a", "b", "c"])
        let parts: Vec<&str> = module_name.split('.').collect();
        if parts.is_empty() {
            return Err("Invalid module name".to_string());
        }

        // Get the current working directory
        let current_dir = std::env::current_dir().map_err(|e| e.to_string())?;

        // Construct directory path from all but the last part
        let dir_path = if parts.len() > 1 {
            parts[..parts.len() - 1].join("/")
        } else {
            "".to_string()
        };

        // Get the last part for the file or directory name
        let last_part = parts.last().unwrap();
        let file_name = format!("{}.bite", last_part);

        // Step 1: Check current directory for module file or directory
        let module_file = current_dir.join(&dir_path).join(&file_name);
        if module_file.is_file() {
            return Ok(module_file);
        }

        let module_dir = current_dir.join(&dir_path).join(last_part);
        if module_dir.is_dir() {
            let main_file = module_dir.join("main.bite");
            if main_file.is_file() {
                return Ok(main_file);
            }
        }

        // Step 2: Check custom or default modules path
        let modules_path = env::var("BITE_MODULES_PATH").unwrap_or_else(|_| "/modules".to_string());
        let modules_base = PathBuf::from(modules_path).join(&dir_path);

        // Check for module file in modules path
        let modules_file = modules_base.join(&file_name);
        if modules_file.is_file() {
            return Ok(modules_file);
        }

        // Check for module directory in modules path
        let modules_module_dir = modules_base.join(last_part);
        if modules_module_dir.is_dir() {
            let main_file_in_modules = modules_module_dir.join("main.bite");
            if main_file_in_modules.is_file() {
                return Ok(main_file_in_modules);
            }
        }

        // If module is not found, return an error
        Err(format!("Module '{}' not found in current directory or modules path", module_name))
    }
}
